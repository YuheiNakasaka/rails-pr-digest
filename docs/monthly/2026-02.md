---
title: 2026年 2月
description: Ruby on Rails PR Digest - 2026年 2月にマージされたPRの要約
lastUpdated: 2026-02-13
---

# Ruby on Rails PR Digest - 2026年 2月

> このページは [rails/rails](https://github.com/rails/rails) リポジトリにマージされたPull Requestを自動的に収集し、AIで要約したものです。


## [#56777](https://github.com/rails/rails/pull/56777) Remove the deprecated `ActiveSupport::Multibyte::Chars` class {#pr-56777}

**マージ日**: 2026/2/12 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
このPRでは、非推奨となっていた `ActiveSupport::Multibyte::Chars` クラスと関連コード／テストが Rails 本体から完全に削除されました。あわせて ActiveRecord のクォート処理からも `Multibyte::Chars` 依存が取り除かれ、マルチバイト文字列処理は Ruby の標準文字列機能＋既存の ActiveSupport 拡張に一本化されています。

---

2. 変更内容の詳細

### 2-1. `ActiveSupport::Multibyte::Chars` 関連の削除

以下のファイルがほぼ丸ごと削除されています:

- `activesupport/lib/active_support/multibyte/chars.rb`
- `activesupport/lib/active_support/multibyte.rb`
- `activesupport/lib/active_support/core_ext/string/multibyte.rb`
- それに関連するテスト一式  
  - `activesupport/test/multibyte_chars_test.rb`
  - `activesupport/test/multibyte_proxy_test.rb`
  - `activesupport/test/multibyte_test_helpers.rb`
  - `activesupport/test/core_ext/string_ext_test.rb` 内の一部
  - など

これにより、以下のような古い書き方は Rails 本体からは消えます:

```ruby
# 旧: Multibyte::Chars を直接使う書き方
s = ActiveSupport::Multibyte::Chars.new("こんにちは")
s.normalize(:kc)
s.length
```

この種の API はすでに長らく非推奨になっており、実装も proxy 的なラッパークラス (`Chars`) を経由する形でしたが、それ自体が完全に削除されています。

### 2-2. ActiveRecord の `quote` 周りからの参照削除

`activerecord/lib/active_record/connection_adapters/abstract/quoting.rb` から `ActiveSupport::Multibyte::Chars` への参照が削除・置き換えられました（差分は +2/-2 と少ないですが、依存削除の要となる変更です）。

もともと:

- DB への文字列クォート処理 (`quote`) の中で、マルチバイト文字列の長さや切り詰め等に `Multibyte::Chars` が利用されていた

PR本文の説明にあるとおり、元々は「eager load 対象にするか検討中だったが、そもそも削除予定なのでこのタイミングで消した」という流れです。

現在は Ruby の `String` と ActiveSupport の標準拡張 (`mb_chars` まわりも含め) を前提に処理が組まれており、`Chars` クラス自体への直接依存はなくなりました。

### 2-3. テストと CHANGELOG の更新

- `activerecord/test/cases/quoting_test.rb` と `sanitize_test.rb` から、`Multibyte::Chars` を前提にしたテストが削除されています（-7 行, -20 行）。
- `activesupport/test/logger_test.rb` では、ログ出力とマルチバイトの扱いに関するテストが、新しい前提（`Chars` なし）に合わせて微調整されています（+3/-1）。
- `activesupport/CHANGELOG.md` に、`ActiveSupport::Multibyte::Chars` が削除されたことを明記する項目が追加されています（+6 行）。

---

3. 影響範囲・注意点

### 3-1. 自前で `ActiveSupport::Multibyte::Chars` を使っているアプリ／ライブラリ

**最も直接的な影響**はここです。

以下のようなコードは、Rails のこのバージョン以降では動かなくなります:

```ruby
# NG: もう存在しないクラスに依存している
ActiveSupport::Multibyte::Chars.new("こんにちは")
ActiveSupport::Multibyte::Chars.u_unpack("あ")
some_string.mb_chars.class == ActiveSupport::Multibyte::Chars
```

対処としては:

- **そのまま Ruby の `String` / `String#length` / `String#slice` などで代替できないか**検討  
  - 近年の Ruby は UTF-8 前提のマルチバイト文字列処理が十分強力です。
- どうしても `mb_chars` 系の機能が必要なら:
  - 現時点では `String#mb_chars` がどう扱われるか（互換レイヤが残るか）は PR diff だけでは確定しませんが、既存の ActiveSupport の他の multibyte ユーティリティを利用する／外部 gem に移行する、などの検討が必要です。
- gem やエンジンで `ActiveSupport::Multibyte::Chars` を参照している場合は、**この Rails バージョンをサポートするにはコード修正が必須**になります。

### 3-2. ActiveRecord のクォート／サニタイズ周り

- `quote` / `sanitize_sql` 自体の表面 API は変わっていませんが、その内部で `Multibyte::Chars` を通さなくなったことで、**極端なマルチバイト境界の切り詰め挙動が微妙に変わる可能性**があります。
- 一般的な利用（日本語・絵文字を含む文字列をバインドパラメータで渡す程度）では、実害はほぼ出ないと考えられますが、
  - DB の制約ギリギリのカラム長を計算してトリムしているようなコード
  - 特定バイト長での切り詰めを前提とした仕様
  を持つアプリでは、テストを走らせて挙動確認しておくと安全です。

### 3-3. 将来バージョンへのアップグレード計画

- 既に `ActiveSupport::Multibyte::Chars` は非推奨であるとアナウンスされていたため、**この削除は予定されていた互換性破壊変更（breaking change）**です。
- アップグレードガイド（`guides.rubyonrails.org` の release note / upgrading guide）にも追って記載されるはずなので、そこも合わせて確認するのがおすすめです。
- アプリや利用中の gem のコードベース内で:
  - `"ActiveSupport::Multibyte::Chars"`
  - `"ActiveSupport::Multibyte"`
  - `"mb_chars"`
  を grep しておき、`Chars` 自体に依存していないか・代替可能かを確認しておくと移行がスムーズです。

---

4. 参考情報 (あれば)

- この PR: https://github.com/rails/rails/pull/56777  
- 過去の非推奨アナウンス／CHANGELOG (`ActiveSupport::Multibyte::Chars` deprecation)  
  - `activesupport/CHANGELOG.md` に今回の削除が追記されているため、同じセクション周辺に過去の非推奨告知も記載されている可能性が高いです。
- Ruby 本体のマルチバイト処理:
  - `Encoding.default_external` が UTF-8 前提であること
  - `String#each_char`, `String#size`, 正規表現（`/u` フラグ）などでの Unicode 対応が十分成熟している点  
  これらを踏まえ、Rails が独自の multibyte ラッパークラスを持ち続ける必要性が減ったことが、この削除の背景にあります。

---


## [#56201](https://github.com/rails/rails/pull/56201) Load hook guard {#pr-56201}

**マージ日**: 2026/2/11 | **作成者**: [@gmcgibbon](https://github.com/gmcgibbon)

1. 概要 (1–2文で)  
Rails の `ActiveSupport.on_load` フックが「アプリ初期化前」に実行されてしまう問題を検知するため、`Rails::Railtie` にロードフック用のガード機構 `guard_load_hooks` が追加されました。これにより、フレームワーク自身および Railtie/Engine を持つ gem が、フックの早期実行をログ出力や例外で検知できるようになります。

---

2. 変更内容の詳細  

### 2-1. `Rails::Railtie#guard_load_hooks` の追加

`railties/lib/rails/railtie.rb` に新メソッド `guard_load_hooks` が追加されました。役割は「特定の load hook が Rails アプリケーション初期化前に呼ばれたら、それを検知してログ or 例外を発生させる」ことです。

おおまかなイメージ:

```rb
class MyRailtie < Rails::Railtie
  # 例: Active Record 用の load hook にガードを付ける
  guard_load_hooks :active_record, raise_on_early_load: false
end
```

想定される挙動（概念的なもの）:
- `ActiveSupport.on_load(:active_record)` がどこかで評価される。
- 実際にそのフックが「実行」されるタイミングで、Rails アプリがまだ `initialized?` でなければ、
  - デフォルトではログに「:active_record がアプリ初期化前にロードされた」旨を警告として出す。
  - 設定によっては `raise_on_early_load: true` のようにして例外を投げることも可能。

実装としては、`ActiveSupport.on_load` 自体を書き換えるのではなく、Railtie 側が hook 名ごとに監視用ラッパを登録し、フック発火時にアプリケーション状態を確認する、という形になっていると考えられます。

### 2-2. 各フレームワークへのガード適用

以下の Railtie / Engine で `guard_load_hooks` が呼ばれるようになり、Rails 標準コンポーネントの主要な load hook がガード対象になりました。

- `action_cable/engine.rb`
- `action_mailbox/engine.rb`
- `action_mailer/railtie.rb`
- `action_controller/railtie.rb`
- `action_dispatch/railtie.rb`
- `action_text/engine.rb`
- `action_view/railtie.rb`
- `active_job/railtie.rb`
- `active_model/railtie.rb`
- `active_record/railtie.rb`
- `active_storage/engine.rb`
- `active_support/railtie.rb`

たとえば `ActiveRecord::Railtie` では、`:active_record` 用の load hook に対してガードが設定されるようになっています。これにより、Active Record 関連のフックがアプリ初期化前に走った場合、ログや例外で気づけるようになります。

### 2-3. 設定オプションの追加

`railties/lib/rails/application/configuration.rb` に設定項目が追加され、`guard_load_hooks` の挙動をアプリ設定から制御できるようになったと考えられます。

テスト (`configuration_test.rb`) の差分から推測できる事項:
- 新しい config オプション（名前は PR 全文がないため正確には断言できませんが、例えば `config.guard_load_hooks` や `config.raise_on_early_load_hooks` のようなもの）が追加されている。
- それを true/false で切り替えて、早期ロードが
  - ログで済むのか
  - 例外として扱われるのか
  を選択できる。

### 2-4. ドキュメント・ガイドの更新

`guides/source/configuring.md` に設定オプションの説明が追加されました。  
ここに「load hook ガードを有効/無効にする方法」や「早期ロード時に raise させる設定」が記載されているはずです。

---

3. 影響範囲・注意点  

### 3-1. どんなときに影響を受けるか

- `ActiveSupport.on_load(:active_record)` などの load hook 内で、**アプリケーション初期化前に実行されるようなコード**を書いている場合:
  - 今までは静かに動いていたものが、**ログに警告が出る**ようになります。
  - 設定次第では **例外が発生してブートが失敗**する可能性があります。
- gem や社内ライブラリで Railtie/Engine を定義しており、その中で load hook を使っている場合:
  - この PR と同様に `guard_load_hooks` を組み込むことで、自分たちの hook の早期ロードを検知できるようになります。

### 3-2. すぐに出そうな問題のパターン

以下のようなケースは、この PR によるガードで顕在化しやすくなります。

```rb
# config/initializers/some_initializer.rb
ActiveSupport.on_load(:active_record) do
  # ここで Rails.application.config を前提にした処理をしているが、
  # 実際にはブートより早く呼ばれてしまっている、など
end
```

- これまでは「たまたま動いていた」ものが、「早期ロードしている」として警告／例外対象になる可能性があります。
- とくに、autoload によってモデルや AR 関連クラスが思わぬタイミングでロードされ、結果として load hook が起動してしまう、という潜在的な不具合・パフォーマンス問題が **検知可能になる** という意図です。

### 3-3. 対応方針

- Rails アップグレード後に、ブート時やテスト時に
  - 「XX がアプリケーション初期化前にロードされた」系のログ
  - あるいは例外
  を見つけた場合は、その load hook をどこから呼んでいるかを追い、**初期化完了後に実行されるようにコードを整理**するのが望ましいです。
- 一時的に問題を避けたい場合は、ガード設定を「ログのみ」にする・無効にする、といった回避も設定オプション経由でできるはずです（`config` オプションのガイドを要確認）。

---

4. 参考情報 (あれば)  

- 元 PR: https://github.com/rails/rails/pull/56201  
- 参考 PR（作者がインスパイア元として挙げているもの）: https://github.com/rails/rails/pull/46047  
  - こちらも load hook や初期化タイミングに関する議論が含まれているため、あわせて読むと背景理解に役立ちます。

この変更は、「早期ロードによるバグやパフォーマンス劣化」を表面化させるものなので、短期的にはノイズが増える可能性がありますが、中長期的にはアプリや gem の初期化順序を健全に保つ助けになります。

---


## [#56778](https://github.com/rails/rails/pull/56778) Deprecate Mail::Address.wrap {#pr-56778}

**マージ日**: 2026/2/11 | **作成者**: [@gmcgibbon](https://github.com/gmcgibbon)

1. 概要 (1-2文で)  
`Mail::Address.wrap` が Rails 8.2 で削除予定の非推奨APIとしてマークされました。Action Mailbox 側でこのメソッドを使っている箇所とテスト・CHANGELOGに、非推奨であることが明示されています。

---

2. 変更内容の詳細  

※PR本文自体は短く、「未使用パッチなので非推奨にする」という意図のみですが、diff から読み取れる典型的な内容を整理します。

- `Mail::Address.wrap` の非推奨化  
  - Action Mailbox が内部で使っている `Mail::Address.wrap` に対して、Rails 8.2 で削除予定である旨の deprecation を追加。
  - 典型的には以下のような形で警告を出す処理が追加されていると考えられます（実際のコードイメージ）:

    ```ruby
    # action_mailbox/lib/action_mailbox/mail_ext/address_wrapping.rb
    module ActionMailbox
      module MailExt
        module AddressWrapping
          def wrap(address)
            ActiveSupport::Deprecation.warn(
              "Mail::Address.wrap は Rails 8.2 で削除されます。代わりに XXX を利用してください。"
            )

            super
          end
        end
      end
    end
    ```

    実際の文言や置き換え候補はPR本文には書かれていないため、ここは概念的な例です。

- CHANGELOG の更新  
  - `actionmailbox/CHANGELOG.md` に以下のようなエントリが追加:
    - `Mail::Address.wrap` が非推奨であり、8.2 で削除予定であること
    - Action Mailbox 利用者向けの注意喚起

- テストの更新  
  - `actionmailbox/test/unit/mail_ext/address_wrapping_test.rb` が更新され、非推奨警告が正しく出ること、あるいは新しい挙動に沿ったテストに変更。
  - 例としては以下のようなテスト変更が想定されます:

    ```ruby
    def test_wrap_is_deprecated
      assert_deprecated do
        Mail::Address.wrap("user@example.com")
      end
    end
    ```

    実際のテストのメソッド名・内容は若干異なる可能性がありますが、行数の増減 (+5, -3) から、既存テストに deprecation 周りのアサーションが足された程度の小さな変更です。

---

3. 影響範囲・注意点  

- 影響を受ける可能性がある人
  - アプリケーションやライブラリ側で **直接 `Mail::Address.wrap` を呼び出している** 場合
  - Action Mailbox の mail 拡張 (`ActionMailbox::MailExt`) を独自に monkey patch している場合

- 実行時の変化
  - Rails 8.1 系（もしくはこのPRが入る次のマイナーバージョン）から、
    - `Mail::Address.wrap` 呼び出し時に deprecation warning が出るようになります。
  - 8.2 で **完全削除される予定** なので、8.2 に上げると NoMethodError などになる可能性があります。

- 対応方針
  - 自前コードで `Mail::Address.wrap` を使っているか検索し、代替実装への置き換えを検討してください。
    - 多くの場合、単純には `Mail::Address.new` で十分なケースが多いです:

      ```ruby
      # 以前:
      address = Mail::Address.wrap("user@example.com")

      # 代替案の一例:
      address = Mail::Address.new("user@example.com")
      ```

    - `wrap` に固有の挙動（配列を受け取って複数アドレスに対応する、nilを許容する等）に依存している場合は、その部分を自前ロジックで実装する必要があります。
  - ライブラリ側で `Mail::Address.wrap` を public API として露出している場合は、
    - ライブラリのドキュメントに「非推奨 API に依存している」旨を明記し、
    - 将来の Rails 8.2 対応版で置き換える方針を検討するべきです。

---

4. 参考情報 (あれば)  

- 該当PR: https://github.com/rails/rails/pull/56778  
- `Mail::Address` は `mail` gem のクラスであり、Rails Action Mailer / Action Mailbox が内部で利用している。  
- 近年の Rails コアでは、Action Mailer / Action Mailbox 周りでの「Rails 非依存な mail gem API」や未使用パッチの整理が継続的に行われており、この PR もその一環と考えられます。

---


## [#56767](https://github.com/rails/rails/pull/56767) Don't eagerly cache JSON Encoder in ActiveRecord::Type::Json {#pr-56767}

**マージ日**: 2026/2/11 | **作成者**: [@xathien](https://github.com/xathien)

1. 概要 (1-2文で)  
ActiveRecord::Type::Json が JSON エンコーダを「クラス読み込み時に自前でキャッシュ」するのをやめ、ActiveSupport::JSON 側のキャッシュ済みエンコーダと `without_escaping` オプションをそのまま使うように変更した PRです。これにより、アプリ側で JSON エンコーダを後から上書き（カスタマイズ）できるようになります。

---

2. 変更内容の詳細  

※ 実際の diff は 1 行追加・3 行削除と小さい変更です。

### これまでの問題点

`ActiveRecord::Type::Json` は、クラスが最初に参照されたタイミングで JSON エンコーダ（例: `ActiveSupport::JSON::Encoding::JSONGemEncoder` など）を取得し、クラスレベルでキャッシュしていました。

疑似コードで表すとおおよそ以下のようなイメージです:

```ruby
# 変更前イメージ（擬似）
module ActiveRecord
  module Type
    class Json < ActiveModel::Type::Value
      ENCODER = ActiveSupport::JSON::Encoding.json_encoder

      def serialize(value)
        ENCODER.new.encode(value)
      end
    end
  end
end
```

このように「クラス読み込み時に固定」してしまうと、

```ruby
# アプリケーション側であとからエンコーダを差し替えたい
ActiveSupport::JSON::Encoding.json_encoder = MyCustomJsonEncoder
```

のような変更を行っても、`Json` 型はもともと取得した古い `ENCODER` を使い続けてしまい、エンコーダの上書きが反映されません。

### 今回の変更

この PR では、`Json` 型自身がエンコーダをキャッシュするのをやめて、`ActiveSupport::JSON` が内部で持つ「キャッシュ済みエンコーダ」と `without_escaping` オプションを利用するようにしました。

イメージとしてはこんな形に近づきます:

```ruby
# 変更後イメージ（擬似）
module ActiveRecord
  module Type
    class Json < ActiveModel::Type::Value
      def serialize(value)
        ActiveSupport::JSON.encode(value, escape: :without_escaping)
        # もしくは:
        # ActiveSupport::JSON::Encoding.json_encoder
        #   .new(without_escaping: true)
        #   .encode(value)
      end
    end
  end
end
```

ポイントは以下の2つです。

- 「エンコーダのインスタンス／クラス」を `ActiveRecord::Type::Json` 側で固定しない
- `ActiveSupport::JSON` が持つ
  - 「選択されたエンコーダのキャッシュ」
  - `without_escaping` (HTML エスケープしない) のビルド済みオプション
  をそのまま利用する

これにより、アプリ側で

```ruby
ActiveSupport::JSON::Encoding.json_encoder = MyCustomJsonEncoder
```

のように設定すると、その後の `ActiveRecord::Type::Json` のシリアライズでも新しいエンコーダが使われるようになります。

---

3. 影響範囲・注意点  

- 影響範囲
  - ActiveRecord の JSON 型（`t.json` カラムや `serialize :data, JSON` に相当する部分）で使われる JSON シリアライズ処理。
  - 特に、「`ActiveSupport::JSON::Encoding.json_encoder` をアプリケーション側で差し替えている」ケースに影響します。
    - これまで: 差し替えても `ActiveRecord::Type::Json` には反映されなかった。
    - これから: 差し替えが正しく反映され、期待どおりカスタムエンコーダが使われる。

- 互換性
  - ActiveSupport::JSON が提供するキャッシュ済みエンコーダを使うだけなので、デフォルト設定で使っている限りは挙動の変化はほぼありません。
  - 逆に「`Json` 型だけは昔のエンコーダのままでいてほしい」といった、非常に特殊な依存をしていた場合は、挙動が変わる可能性があります（一般的には望ましい修正）。

- パフォーマンス
  - ActiveSupport 側でエンコーダはすでにキャッシュされており、`Json` 型で二重にキャッシュする必要はありません。
  - そのため、パフォーマンス的な悪化は基本的に想定されず、むしろ実装の一貫性が増しています。

- テストについて
  - PR 本体では新規テスト追加はまだ行われていません（チェックリストでも `Tests` が未チェック）。
  - 適切なテストとしては、以下のようなケースをカバーするとよい:
    - `ActiveSupport::JSON::Encoding.json_encoder` をカスタムクラスに変更したあとで、`ActiveRecord::Type::Json#serialize` がそのカスタムエンコーダ経由で呼ばれているかを確認する。

---

4. 参考情報 (あれば)  

- 対応 Issue: [Fix #56766]  
  → 「ActiveRecord::Type::Json で JSON エンコーダを後から上書きできない」不具合の修正 PR。
- 関連箇所:
  - `activerecord/lib/active_record/type/json.rb`
  - `ActiveSupport::JSON` および `ActiveSupport::JSON::Encoding.json_encoder` の実装。  
    カスタムエンコーダを使っているプロジェクトでは、この PR により「ActiveRecord と ActiveSupport の JSON エンコード戦略の一貫性」が向上します。

---


## [#56761](https://github.com/rails/rails/pull/56761) EventReporter: filter events before building the payload {#pr-56761}

**マージ日**: 2026/2/11 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
このPRは、`ActiveSupport::EventReporter` で「イベントペイロードのフィルタリング」を、**ペイロード構築の後ではなく前に行う**ように変更し、無駄なオブジェクト生成コストを削減するものです。これにより、AS::Notifications 由来の「フィルタによる最適化」が、実際にオーバーヘッド削減として意味を持つようになります。

---

2. 変更内容の詳細  

### 背景
- 以前のPR（#55900）の結果として、
  - イベント発火時に「とりあえずフルのペイロードを構築 → フィルタで削る → 購読者（subscriber）が必要かどうか確認」という順序になっていました。
  - そのため、**購読者がそもそもいなくてもペイロード構築コストを丸ごと払う**状況になっていました。
- `ActiveSupport::Notifications` のもともとの設計では、
  - フィルタや購読状況を見て **不要ならペイロード構築をそもそもしない**、という形でオーバーヘッド削減をしていました。
- 現状の EventReporter では、フィルタを登録しても「ペイロード構築の無駄」を避けられないため、フィルタ機能がパフォーマンス観点では意味をなしていない、という問題意識があります。

### このPRでのコア変更点
`activesupport/lib/active_support/event_reporter.rb` への主な変更は次の通りです（概念ベース）:

1. **イベントペイロードを組み立てる順序の変更**
   - 以前:  
     1. フルのペイロードを構築  
     2. フィルタでマスキング・削除等の処理  
     3. 購読者に配信すべきか判定 / 配信  
   - 変更後:  
     1. 購読者やフィルタ情報を元に「必要な形」を把握  
     2. その要件に沿ってペイロードを構築（あるいは最小限に抑える）  
     3. フィルタを適用しつつ購読者に配信  

   これにより、「どうせ誰も見ない / ほとんど使わない情報」を構築するコストを省けるようになります。

2. **フィルタの意味づけの修正**
   - 以前は「ペイロードを後から編集・フィルタするだけ」のロジックだったのに対して、
   - 今回の変更により、「**ペイロード構築前に、どの情報が必要かを決めるためにフィルタを利用する**」という、本来 AS::Notifications が意図していた用途に近づけています。

3. CHANGELOG への追記
   - `activesupport/CHANGELOG.md` にこの挙動変更が追記されています。
   - 著者自身も説明文中で「技術的には breaking change（挙動変更）」と認めており、CHANGELOG でもその旨が（互換性への影響として）記録されているはずです。

### 簡略イメージコード（概念）

※実際のコードとは異なる擬似コードですが、挙動の違いを表します。

```ruby
# 変更前（イメージ）
def report(name, payload_builder)
  full_payload = payload_builder.call            # ここでコスト全払い
  filtered_payload = apply_filters(full_payload) # 後から削るだけ
  notify_subscribers(name, filtered_payload)
end

# 変更後（イメージ）
def report(name, payload_builder)
  # フィルタや購読状況から必要な情報を推定（例: keys, fields など）
  build_context = compute_build_context(name, filters, subscribers)

  # build_context に基づいて「必要なものだけ」構築させる
  payload = payload_builder.call(build_context)

  filtered_payload = apply_filters(payload)
  notify_subscribers(name, filtered_payload)
end
```

実際には `build_context` 相当の情報の扱いなどはもっと細かいですが、  
「フィルタ・購読状況 → それを踏まえてペイロードを作る」という流れに変わった、という理解で概ね問題ありません。

---

3. 影響範囲・注意点  

- **挙動上の breaking change の可能性**
  - 著者も認めているように、「フィルタの適用タイミング」が変わるため、  
    - ペイロード生成ロジック（特に副作用を伴うもの）  
    - フィルタが前提としていたペイロードの内容・形  
    に影響が出る可能性があります。
  - 通常はペイロードを「純粋なデータ生成」として扱っていれば問題になりにくいですが、もし「必ずこの時点でペイロードがフルに構築されている」ことを前提にしたコードがあれば、その前提が崩れる可能性があります。

- **パフォーマンスへのポジティブな影響**
  - イベント数が多く、かつペイロード構築が高コストなケース（DBからの追加クエリ、重いオブジェクト生成など）では、**不要なイベント・不要なフィールド分のコスト削減**が期待できます。
  - 特に「本番環境ではサブスクライバをほとんど登録していない」「特定のイベントだけを絞って監視している」ようなケースで効果が出やすいです。

- **フィルタ実装・利用者への注意**
  - `EventReporter` のフィルタを使っている場合、
    - 「ペイロード構築前か後か」に依存した奇抜な実装をしていないか
    - フィルタが「存在しないキーや値」を前提としていないか
  を確認した方が安全です。
  - ただし、このPRの主眼は「ペイロード構築順序と無駄の削減」であり、フィルタAPIの表面的なシグネチャが大きく変わるわけではないため、多くの通常利用コードはそのまま動くと考えられます。

---

4. 参考情報 (あれば)  

- 対応する前提PR:  
  - https://github.com/rails/rails/pull/55900  
    （これにより、いったん「必ずペイロードを作ってからフィルタ」という流れになっていた）
- 対象ファイル  
  - `activesupport/lib/active_support/event_reporter.rb`  
  - `activesupport/CHANGELOG.md`
- 著者のコメント上の論点
  - AS::Notifications から移植されたフィルタ機能が、「ペイロード構築をスキップできない」という点で意味をなしていないと判断し、その設計意図（オーバーヘッド削減）に沿うように挙動を修正している。

---


## [#56769](https://github.com/rails/rails/pull/56769) Bump Valkey Redis Image version to 9 {#pr-56769}

**マージ日**: 2026/2/11 | **作成者**: [@akhilgkrishnan](https://github.com/akhilgkrishnan)

1. 概要 (1-2文で)  
Valkey の Redis コンテナイメージのバージョンを、Rails リポジトリ内で使っている devcontainer と CI 設定一式で「9」系の最新版に統一して引き上げた PRです。開発用コンテナ、Rails アプリ／プラグイン ジェネレータのテンプレート、そしてそれらを検証するテストが、すべて Valkey 9 を前提に動くようになります。

---

2. 変更内容の詳細  

この PRがやっていることは「Valkey イメージのタグを書き換える」一点にほぼ集約されています。

### 対象となった場所

- 開発者向け devcontainer 設定
  - `.devcontainer/compose.yaml`
  - `railties/lib/rails/generators/rails/devcontainer/templates/devcontainer/compose.yaml.tt`
  - `railties/test/fixtures/.devcontainer/compose.yaml`
- CI / デプロイ関連テンプレート
  - `railties/lib/rails/generators/rails/app/templates/github/ci.yml.tt`
  - `railties/lib/rails/generators/rails/plugin/templates/github/ci.yml.tt`
  - `railties/lib/rails/generators/rails/app/templates/config/deploy.yml.tt`
- テストコード
  - `railties/test/generators/app_generator_test.rb`
  - `railties/test/generators/devcontainer_generator_test.rb`

これらのファイルで指定されていた Valkey の Docker イメージが、旧バージョン（例: `valkey/valkey:8` など）から最新の `valkey/valkey:9` に変更されています。  
具体的には、以下のような差分が入っていると考えてよいです:

```yaml
# 例: devcontainer や CI の redis サービス定義
services:
  redis:
    image: valkey/valkey:9
    # 以前は valkey/valkey:8 などの指定だった
```

テンプレートの変更に合わせて、それを前提としているテスト (`app_generator_test.rb`, `devcontainer_generator_test.rb`) 内の期待値も、Valkey 9 のイメージタグを参照するように1行ずつ更新されています。

---

3. 影響範囲・注意点  

**影響範囲**

- Rails 本体のランタイムコードには手は入っていないため、Rails アプリケーションの挙動そのものには影響しません。
- 次のような「テンプレートを使う人」や「公式の devcontainer/CI 設定に従う人」に影響があります:
  - Rails の devcontainer テンプレートから新規プロジェクトを作る場合
  - `rails new` によって生成される GitHub Actions CI 設定（`github/ci.yml`）を利用する場合
  - `rails plugin new` で作るプラグインの CI 設定テンプレートを利用する場合
  - Rails リポジトリの `.devcontainer` を使って開発環境を構築している場合

**注意点**

- **Valkey 9 の互換性**  
  基本的に Redis プロトコル互換なので、通常の Rails + Redis (Valkey) を使ったキャッシュやセッション用途では問題は起きにくいと想定されますが、以下のような場合は要注意です:
  - 特定の Redis バージョン依存の挙動を前提にしたコードやテストがある
  - 古い Valkey/Redis イメージでのみ再現するバグや仕様に依存している
- **CI・devcontainer が突然落ちる可能性**  
  - ローカル環境や CI 環境がキャッシュしている古いイメージタグを前提にしている場合、タグ更新後に `docker compose` や CI が新しいイメージを pull し直すことで、一時的にビルド時間が伸びる可能性があります。
  - 非公式ミラーやカスタムレジストリを使っている場合、`valkey/valkey:9` が存在しないと CI で失敗することがあります。その場合はレジストリ側の対応が必要です。

---

4. 参考情報 (あれば)  

- Valkey 公式 Docker Hub  
  - https://hub.docker.com/r/valkey/valkey/  
  ここから `9` タグの正式サポート状況や、`8` からの変更点を確認できます。
- Rails のジェネレータが生成する CI/devcontainer 設定をベースに自前の設定をカスタマイズしている場合、この PR を機に自分のリポジトリ側でも Valkey イメージのバージョンを揃えておくと、今後の Rails 本体との齟齬が減らせます。

---


## [#56768](https://github.com/rails/rails/pull/56768) Fix Marshal deserialisation of Integer type from Rails 8.0 {#pr-56768}

**マージ日**: 2026/2/11 | **作成者**: [@RemoteCTO](https://github.com/RemoteCTO)

1. 概要 (1-2文で)  
Rails 8.0 で Marshal シリアライズした `ActiveModel::Type::Integer` オブジェクトを Rails 8.1 でデシリアライズすると `NoMethodError: undefined method '<=' for nil` が発生するリグレッションを修正した PRです。8.0 → 8.1 へのアップグレード時に、キャッシュ等に Marshal された型オブジェクトが残っている環境での互換性問題を解消します。

---

2. 変更内容の詳細  

### 問題の原因

元のパフォーマンス改善 PR (#53470) で、`ActiveModel::Type::Integer` の初期化処理が以下のように変更されていました:

- 以前: `@range` という Range オブジェクトで最大/最小値を管理
- 変更後: `@max` / `@min` という 2 つのインスタンス変数で数値として管理

ところが、`Marshal.load` は `initialize` を呼ばずにインスタンス変数をそのまま復元します。そのため:

- Rails 8.0.x でシリアライズされたオブジェクト: `@range` はあるが `@max` / `@min` は存在しない状態で保存されている
- Rails 8.1.x のコードは `@max` / `@min` を前提にしている

結果として:

```ruby
def out_of_range?(value)
  # イメージ
  value < @min || @max < value
end
```

のような処理を行う際に、`@min` / `@max` が `nil` のままになり、`nil <= value` が呼ばれて `NoMethodError` になる、という問題が発生していました。

### 修正内容

`@max` / `@min` が `nil` の場合に、`max_value` / `min_value` から「遅延初期化」するガードを追加しています。

概念的には次のようなコードが追加されたイメージです（簡略化した擬似コード）:

```ruby
def out_of_range?(value)
  # 8.0 時代に Marshal されたオブジェクトを 8.1 で読むと
  # @max / @min が nil のままなので、ここで一度だけ復元する
  if @max.nil? || @min.nil?
    @max = max_value   # limit から計算される
    @min = min_value   # limit から計算される
  end

  value < @min || @max < value
end
```

ポイント:

- `max_value` / `min_value` は親クラス (`Value`) によって `limit` から計算されるもので、`limit` 自体は Marshal によって正しく復元されている
- そのため、`limit` から改めて `@max` / `@min` を計算し直せば、8.0 時代のシリアライズ済みオブジェクトも正しく動く
- ガードは一度通れば `@max` / `@min` がセットされるため、通常の実行パスの性能には影響しない（初回だけのデグレードパス）

### テスト

`activemodel/test/cases/type/integer_test.rb` にテストが追加されています。内容的には以下のようなケースをカバーしているはずです:

- Rails 8.0 形式（`@range` を持ち、`@max` / `@min` がない）に相当するオブジェクトを用意し、Marshal シリアライズ → デシリアライズ
- その後 `cast` など `out_of_range?` を内部的に呼ぶ処理を実行しても `NoMethodError` が起きず、期待通りに動作することを確認

---

3. 影響範囲・注意点  

- 影響を受けるケース
  - Rails 8.0.x で `ActiveModel::Type::Integer` オブジェクトを `Marshal.dump` してどこかに保存している（典型例: キャッシュ、スキーマキャッシュ、属性ビルダーのキャッシュなど）
  - そのまま Rails 8.1.x にアップグレードし、既存の Marshal データを `Marshal.load` して利用している
  - かつ、デフォルトの marshalling format (6.1) を利用しているケースが特に影響を受ける

- ActiveRecord オブジェクトについて:
  - marshalling format を 7.1 に上げると、`ActiveRecord::Base` オブジェクトについては問題をある程度回避できるが、`Type` オブジェクトは他の文脈（スキーマキャッシュなど）にも現れるため、根本的には `Type` クラス自体の互換性が必要 → 本 PR がその対応

- 既知のワークアラウンド
  - 「キャッシュを全部捨てる（flush）」ことで問題は解消できるが、マイナーバージョンアップでそれを必須にしたくない、という考えからコード側での後方互換性対応が追加された

- 性能面
  - ガードは「`@max` / `@min` が `nil` の場合のみ」実行され、一度値がセットされれば以降は通常通りの高速パスで動作する
  - したがって、通常の 8.1 以降ネイティブなオブジェクトに対しては性能劣化はほぼ無視できる

---

4. 参考情報 (あれば)  

- この PR が修正しているリグレッション:  
  - #53470 (Integer 型のパフォーマンス最適化による副作用)
- 対象バージョン:
  - Rails 8.1 系での利用を想定
  - PR 内で `8-1-stable` へのバックポート希望が述べられているため、8.1.x 系への反映が期待される
- 運用上のヒント:
  - すでに 8.1 に上げていて、`undefined method '<=' for nil` が Integer 型周りで出ている場合:
    - このパッチを取り込む（または 8.1.x の該当修正版にアップデートする）
    - もしくは暫定的に該当キャッシュ（スキーマキャッシュ / Rails.cache など）を flush することで応急対応可能  
  - 今後のアップグレード時も「型オブジェクトなど内部オブジェクトの Marshal 互換性」による不具合が起こりうるため、キャッシュと Marshal 利用箇所の洗い出しを行っておくと安全です。

---


## [#56763](https://github.com/rails/rails/pull/56763) Fix rdoc code formatting {#pr-56763}

**マージ日**: 2026/2/11 | **作成者**: [@tjschuck](https://github.com/tjschuck)

1. 概要 (1-2文で)  
Rails の `ActionView::Helpers::TextHelper#highlight` の RDoc コメント内のコード例について、インラインコードのマークアップ方法を `+...+` から `<tt>...</tt>` に変更し、公式ドキュメント上でコードが正しく整形・表示されるようにする修正です。機能仕様や挙動には一切変更はなく、ドキュメント表示のみを直す PR です。

---

2. 変更内容の詳細  

- 対象ファイル:  
  `actionview/lib/action_view/helpers/text_helper.rb`

- 変更内容:  
  `highlight` メソッドの RDoc コメント中に記載されている「少し複雑なコードスニペット」のマークアップを、`+code+` 形式から `<tt>code</tt>` 形式に変更しています。

- 背景:
  - RDoc ではインラインコードとして `+code+` という書き方ができますが、  
    - 文字列中に `+` を含む  
    - あるいは記号・正規表現・ブロック付き呼び出しなどが入り組んだ「複雑なスニペット」  
    では、`+...+` だけではパースに失敗したりレイアウトが崩れたりすることがあります。
  - この PR の説明で挙げられている URL（edgeapi の `TextHelper#highlight`）では、まさにその崩れが発生しており、コード例が途中で途切れたり HTML として誤解釈されていました。

- 修正のイメージ:  
  実際の行は 1 行だけ差し替えですが、やっていることは以下のような変換です（擬似例）:

  ```rdoc
  # 変更前（うまく解釈されていなかった）
  #   +highlight(text, ['rails', 'Ruby'], highlighter: '<strong class="highlight">\1</strong>')+
  #
  # 変更後（<tt> でインラインコードを明示）
  #   <tt>highlight(text, ['rails', 'Ruby'], highlighter: '<strong class="highlight">\1</strong>')</tt>
  ```

  `+...+` が、RDoc の「インラインコード」かつ「テキストの強調」のショートハンドなのに対し、`<tt>...</tt>` は HTML タグとしてより直接的・確実に「等幅フォントのコード」として扱われます。そのため、特殊文字を含む複雑なスニペットでも崩れにくくなります。

---

3. 影響範囲・注意点  

- ランタイム挙動:
  - Ruby/Rails の実行時挙動には一切影響しません。`TextHelper#highlight` の実装ロジックや API 仕様は変わっていません。

- 影響するのはドキュメントのみ:
  - `edgeapi.rubyonrails.org` など RDoc 生成済み API ドキュメントにおける、`highlight` の説明セクションの見た目と整形のみが変わります。
  - これまで崩れていたコードサンプルが、1 行のインラインコードとして正しく表示されるようになります。

- プロジェクト側での注意点:
  - Rails 本体に限らず、自分のライブラリやアプリで RDoc を利用している場合、
    - 複雑なコード例（正規表現、ブロック、ネストした `'`/`"` など）を `+...+` で囲んでいると同様の問題が起きる可能性があります。
    - そうした箇所は `<tt>...</tt>`（または複数行なら `:markup: rdoc` のコードブロック）への切り替えを検討するとよいです。

---

4. 参考情報 (あれば)  

- 該当ドキュメント（修正前の表示例）  
  https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/TextHelper.html#method-i-highlight  

- RDoc でのインラインコード表現について（概要）  
  - `+code+` … シンプルなインラインコード・強調向け。単純な識別子や短い式に適している。  
  - `<tt>code</tt>` … HTML として扱われるため、RDoc のパーサを回避したい複雑なスニペットに有効。  

この PR は、そのベストプラクティスを Rails 本体のドキュメントにも適用した形になっています。

---


## [#56748](https://github.com/rails/rails/pull/56748) Consistently raise deprecation warnings in CI {#pr-56748}

**マージ日**: 2026/2/10 | **作成者**: [@skipkayhil](https://github.com/skipkayhil)

1. 概要 (1-2文で)  
Rails の各フレームワーク（Action Pack / Action View / Action Mailer / Active Model / Active Record）で、CI 環境における「非推奨機能(deprecation)の扱い」を、Active Support と同様に「ログではなく例外を投げてテストを落とす」挙動に統一した PR です。  
これにより、CI 上で非推奨機能の利用が見逃されにくくなり、非推奨化を導入した PR の時点で対応を強制しやすくなります。

---

2. 変更内容の詳細  

### 2-1. 何をしている PR か

- 以前のコミットで Active Support の deprecator は「CI では `raise` する」ように変更されていたが、他のフレームワークはまだ「フルバックトレース付きでログ出力するだけ」の設定になっていた。
- この PR では以下を行っている:
  - Action Mailer / Action Pack / Action View / Active Model / Active Record のテスト環境設定で、deprecator の挙動を「ログ出力 → 例外を投げる」に変更
  - Rails 内部で利用している一部依存フレームワークの deprecator 設定も追加し、全体として CI 上では deprecation を「テスト失敗」として扱う方針に揃えた

※実際のコード上では、`ActiveSupport::Deprecation.behavior` 相当の設定が「:log」や「バックトレース付きログ」から「:raise」や同等機能へ差し替えられているイメージです。

### 2-2. ファイルごとの変更方向性

差分はすべて「テスト用のセットアップコード」に集中しています。

- `actionmailer/test/abstract_unit.rb`
  - Action Mailer のテスト全体共通セットアップで、deprecator の出力方法を「バックトレース付きログ」から「例外を投げる」設定へ変更。

- `actionpack/test/abstract_unit.rb`
- `actionpack/test/controller/render*_test.rb` 系 4 ファイル
  - Action Pack (特にコントローラの render 系テスト) の共通設定・個別テストで、deprecator の挙動を「raise」に変更。
  - `render_js_test`, `render_json_test`, `render_test`, `render_to_string_test`, `render_xml_test` はいずれも「deprecation を含んだレンダリングパス」が通る可能性があるため、それらが発生したらテストを即座に失敗させるようになる。

- `actionview/test/abstract_unit.rb`
- `actionview/test/actionpack/controller/render_test.rb`
  - Action View 側も同様に、ビュー関連テストで deprecation を例外化する設定に切り替え。

- `activemodel/test/cases/helper.rb`
  - Active Model のテストヘルパでも deprecator 設定を「例外を投げる」に変更。

- `activerecord/test/support/global_config.rb`
  - Active Record のグローバルなテスト設定内で、Active Record 依存の deprecator 設定を強化・追加。
  - これまで設定されていなかった依存関係（例: Rails 外部の deprecation 機構や、サブコンポーネント用の deprecator）がある場合、それらにも一貫して CI で `raise` させるようにしている。

---

3. 影響範囲・注意点  

### 3-1. Rails 本体開発・コントリビュータ視点

- 影響対象は **Rails 本体のテストスイート** およびそれをベースにしている開発環境が主です。
- CI 上で deprecation を発生させるような変更を加えると、**ログに流れるだけではなくテストが失敗する** ようになります。
  - そのため、「古い API を呼ぶだけでテストが落ちる」ケースが増えます。
  - 非推奨化を行う PR では、以下のような対応を同時に行う必要があります:
    - 既存テストを新しい API に書き換える
    - どうしても旧 API を使う必要がある場合は、それを明示的に許容する仕組み（`silence_deprecation` など）で囲む

### 3-2. Rails アプリケーション開発者への間接的な影響

- この PR 自体は **Rails 本体のテスト設定** の話なので、Rails を使うアプリケーションの挙動が直ちに変わるわけではありません。
- ただし、Rails プロジェクトとしての方針は次のように読み取れます:
  - 「CI では deprecation を単なる警告でなく、**エラーとして扱っていく**」方向へ舵を切っている
  - 将来的に、`config.active_support.deprecation = :raise` のような設定を CI で有効にすることが、一般的なベストプラクティスとして推奨されていく可能性が高い

アプリケーション側でも、CI での安全性を高めたい場合は、以下のような設定を検討できます:

```ruby
# config/environments/test.rb または CI 用設定など
config.active_support.deprecation = :raise
# あるいは、フレームワーク個別の deprecator を明示的に raise に設定する
```

### 3-3. テストの書き方に関する注意

- deprecation を発生させること自体をテストしたいケース（「このメソッドは非推奨であることを確認したい」など）では、`assert_raises` などで明示的に例外を検証する必要があります。
- 今後 Rails 本体のテストを読む際、「deprecation を期待しているテスト」は、例外を捕捉する形で書き直されている可能性があります。

---

4. 参考情報 (あれば)

- PR 説明で参照されている過去コミット（Active Support 側の変更）  
  - https://github.com/rails/rails/commit/9bf81e4ba99f90566a456326bb9311fa5902d28a  
  ここで Active Support の deprecator が「CI で raise」するように変更されており、本 PR はそのポリシーを他フレームワークに波及させたものです。

- Rails の deprecation ハンドリングの一般的な設定例
  - `config.active_support.deprecation = :log`   # ログに出す（従来型）
  - `config.active_support.deprecation = :silence` # 無視
  - `config.active_support.deprecation = :raise`  # 例外として扱う（本 PR が採用している方向）

---


## [#56762](https://github.com/rails/rails/pull/56762) ActiveSupport::ParameterFilter: optimize redundant patterns out {#pr-56762}

**マージ日**: 2026/2/10 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
ActiveSupport::ParameterFilter のプリコンパイル処理で、意味的に重複しているフィルタパターンを取り除く最適化が追加されました。これにより、特に Active Record Encryption によって大量の深いフィルタが自動登録されるケースで、パラメータフィルタリングの性能劣化を抑えられます。

---

2. 変更内容の詳細  

### 背景  
- Active Record Encryption は、暗号化カラムごとに「深い」パターンを ActiveSupport::ParameterFilter に登録します（例: `user[credit_card][number]` のようなネストされたキーをまとめてマスクできるようなパターン）。  
- 暗号化カラムが多いアプリケーションでは、このフィルタパターンのリストが急激に増大し、毎回のパラメータフィルタリング処理がボトルネックになり得ます。  
- 特に、カラム名に共通のサフィックス（`*_token` など）が付いていて、かつ `token` 自体がすでにフィルタ対象になっていると、「より広いパターン」と「より狭い（具体的な）パターン」が両方登録されてしまい、後者が事実上「死んだコード」になります（どうせ上位パターンで全部マスクされるため）。

### 今回の最適化の方向性  
- ParameterFilter には「プリコンパイルステップ」があり、渡されたフィルタ条件（文字列/シンボル/正規表現/Proc など）を内部表現に変換しています。  
- このプリコンパイル段階で「どうせ上位のフィルタに含まれているパターン」を検出し、リストから削除する「dead code elimination」を行うようにしました。  

※ PR本文の例:  
- 多くの暗号化カラム: `access_token`, `refresh_token`, `reset_password_token` など  
- すでに `token` がフィルタ対象 (`config.filter_parameters << :token`) の場合、  
  - `:access_token`, `:refresh_token` などを深いパターンで登録しても、`token` で包括的にマスク可能  
  - そのため、これらの細かいパターンは冗長であり、フィルタリストから落としてもマスク結果は変わらない

### 具体的なコードイメージ（擬似例）

たとえば、アプリケーションで次のような設定をしていたとします:

```ruby
Rails.application.config.filter_parameters += [
  :token,                   # 既に広いパターン
  :access_token,
  :refresh_token,
  /.*_token/,               # さらに広い正規表現パターン
]
```

プリコンパイル前は、ほぼ同じ意味のパターンが多数リストに積み上がっていましたが、  
この PR 以降は、プリコンパイル段階で次のように削られます（イメージ）:

- `:token` と `/.*_token/` でマスク範囲が網羅されている場合、`access_token`, `refresh_token` などの個別パターンは「どうせマスクされる」ので削除  
- 結果として、内部的なフィルタリストは最小限のパターン構成になり、ループやマッチング回数が減って高速化

### テストの更新  
- `activesupport/test/parameter_filter_test.rb` が更新され、  
  - 冗長なパターンが自動的に除去されても、最終的なフィルタリング結果（マスクされるキー・値）が以前と変わらないこと  
  - どのような組み合わせのパターンであれば「冗長」と見なされるか  
を検証するテストが追加・修正されています。  
- これにより、「最適化しても挙動（出力のマスク結果）は同じである」ことが保証されています。

---

3. 影響範囲・注意点  

### 主な影響範囲  
- `ActiveSupport::ParameterFilter` を利用するすべての箇所（典型的には Rails のログ出力時のパラメータマスク）。  
- 特に、Active Record Encryption を多用しており、暗号化カラム名に共通サフィックスが付いているようなアプリケーションで効果が大きいです。  
  - 例: `*_token`, `*_ciphertext` など

### 開発者目線でのポイント  

1. **機能的な挙動は変わらない前提**  
   - 意図としては、冗長パターンを削除しても「どのパラメータがマスクされるか」は変わりません。  
   - 最適化の条件判定がバグらない限り、ログの秘匿性（セキュリティ）は維持されます。

2. **パフォーマンス改善が期待できるケース**  
   - `config.filter_parameters` が非常に長くなっている。  
   - Active Record Encryption が大量の「深いフィルタパターン」を自動追加している。  
   - 大きなネスト構造のパラメータ（API payload、フォーム送信など）を頻繁にログ出力している。  
   → こうしたケースで、リクエストログ出力の CPU 使用量や応答時間が多少改善される可能性があります。

3. **カスタムな ParameterFilter 拡張をしている場合の注意**  
   - `ActiveSupport::ParameterFilter` を独自に継承・モンキーパッチしている場合、  
     - プリコンパイルロジックの内部構造に依存しているコードがあれば、衝突の可能性があります。  
   - ただし、この PR は基本的に「より小さいパターンを大きいパターンに吸収する」だけなので、  
     - 公開 API を正しく使っている限り、表向きのインターフェース変更はほぼ無いと考えられます。

4. **デバッグ時の見かけの違い**  
   - `config.filter_parameters` に多くの要素を追加していても、  
     - 内部的なプリコンパイル済みフィルタ構造をデバッグした際には、以前より短く見える可能性があります（冗長分が削除されるため）。  
   - ただし実際のマスク結果は変わらない想定です。

---

4. 参考情報 (あれば)  

- 対象 PR: https://github.com/rails/rails/pull/56762  
- 関連領域:  
  - ActiveSupport::ParameterFilter（パラメータログのマスキング機構）  
  - Active Record Encryption（暗号化属性のための自動フィルタ登録）  
- パフォーマンスに悩んでいる場合の確認ポイント:  
  - `config.filter_parameters` の内容・長さ  
  - 1 リクエストあたりにログに出ているパラメータ構造の複雑さ  
  - `ParameterFilter` 周りに独自の拡張がないかどうか

---


## [#56759](https://github.com/rails/rails/pull/56759) Avoid combinatory explosion of `Rails.app.config.filter_parameters` {#pr-56759}

**マージ日**: 2026/2/10 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
Rails 8.1 で `Rails.application.config.filter_parameters` と Active Record の暗号化属性が組み合わさることで、フィルタ対象の属性リストが爆発的に増え、ログ・イベントのフィルタ処理が極端に遅くなる問題がありました。  
このPRは、その「組み合わせ爆発」が起きないように `filter_attributes` の扱いを修正し、フィルタ処理のパフォーマンスを大幅に改善します。

---

2. 変更内容の詳細  

### 問題の背景

- Rails 8.1 で導入された変更（#55251）により、`ActiveRecord::Base.filter_attributes` は初期値として `Rails.application.config.filter_parameters` を引き継ぐようになった。
- Active Record Encryption を使うと、モデルごとの暗号化属性名が `filter_attributes` に追加される際に「モデル名でネームスペース」される。
  - 例: `User` モデルの `:email` が暗号化されていると `user.email` のような形で追加される（実際の形式は内部実装に依存）。
- 問題は、暗号化属性を追加する処理が `self.filtered_attributes += [attr]` のような形で行われており、「新しい暗号化属性」だけでなく、既存の `config.filter_parameters` のエントリに対してもモデル名でプレフィックスを付けたバリエーションが次々と追加されてしまう点。

結果として:

- `config.filter_parameters` に 30 個
- Active Record Encryption を使うモデルが 30 個ある

といったケースで、

- 元々 30 個だったフィルタパラメータが、モデルごとにプレフィックス付きの組み合わせをどんどん増殖させ、1,000件超のエントリになる。
- これらが 1 つの巨大な正規表現にコンパイルされ、パラメータフィルタリング（ログ用フィルターや EventReporter 用のフィルター）が非常に遅くなる。
  - PR 説明では「軽いはずのコントローラで処理時間の 95% をフィルタリングが消費」というレベル。

### このPRで行った修正の方向性

コード行数の差分から分かる範囲でのポイント:

- `activerecord/lib/active_record/core.rb` で `filter_attributes` / `filtered_attributes` の更新ロジックを変更。
- 目的は「暗号化属性を追加するときに、`Rails.application.config.filter_parameters` 由来のエントリを無闇にモデル名でプレフィックスして増やさない」ようにすること。
- おそらく次のようなアプローチのいずれか（または組み合わせ）で対処している:
  - `filter_attributes` にアプリ共通のグローバルなフィルタと、モデル固有の追加分を区別して管理する。
  - 追加時に「すでに存在するものを再度ネームスペース付きで複製しない」ようにチェックする。
  - あるいは `+=`（配列結合）ベースの実装をやめ、重複や組み合わせ爆発を抑制できるデータ構造・APIに変更する。

### テストの変更

- `railties/test/application/active_record_railtie_test.rb` にテストを追加・修正。
- ねらいとしては:
  - `Rails.application.config.filter_parameters` と Active Record Encryption の組み合わせで、意図しない大量のエントリが `filter_attributes` に入らないことを検証。
  - 暗号化属性が正しくフィルタ対象にはなるが、グローバル設定由来のフィルタパラメータがモデルごとに複製されないことを確認。

サンプルイメージ（擬似コード）

```ruby
# 以前の挙動（問題のあるイメージ）
Rails.application.config.filter_parameters = [:password, :token]

class User < ApplicationRecord
  encrypts :email
end

# 暗号化属性を追加する際に
self.filtered_attributes += [:"user.email"]

# しかし実際には、内部的処理の都合で
# [:password, :token] も "user." プレフィックス付きで再度入ってしまうような挙動になり、
# [:password, :token, :"user.password", :"user.token", :"user.email", ...] などが
# モデル数ぶん増殖する
```

このPRでは、こうした「元の filter_parameters エントリの再プレフィックス＆多重追加」を避けるように修正していると考えられます。

---

3. 影響範囲・注意点  

**影響範囲**

- 対象:
  - Rails 8.1 以降で、
  - `Rails.application.config.filter_parameters` をある程度設定しており、
  - Active Record Encryption を使っているプロジェクト。
- ログフィルタや `ActiveSupport::ParameterFilter` を介したパラメータフィルタリングに関わる処理が高速化される可能性が高いです。
  - PR 作成者の環境では、コントローラ処理時間のほとんどを占めていたフィルタ処理が改善される。

**注意点**

- 仕様として期待されている挙動（
  - `config.filter_parameters` に設定したキーがフィルタされる、
  - 暗号化属性がフィルタされる
  ）は維持されたまま、重複・爆発的な増殖だけが抑制される変更です。
- もし独自に `filter_attributes` / `filtered_attributes` に直接アクセスして実装しているコードがあれば、要確認:
  - これまで「やたら多かったエントリ数」が、正常な量に減る可能性がある。
  - 特定のプレフィックス付きキーを前提としたハック的な実装をしている場合、挙動が変わる可能性はゼロではありません（通常のアプリでは問題にならない想定）。

**パフォーマンス検証のおすすめ**

- Rails 8.1（または edge）でアップグレード後に以下に心当たりがある場合は、このPRが含まれたバージョンで再測定するとよいです:
  - 単純なコントローラでもレスポンスがやたら遅い。
  - プロファイラで見ると、ログフィルタリングや EventReporter 用のフィルタリングがボトルネックになっている。
- `Rails.application.config.filter_parameters` に大量のエントリを入れているプロジェクトでは特に効果があります。

---

4. 参考情報 (あれば)  

- 本PR: `Avoid combinatory explosion of Rails.app.config.filter_parameters` (#56759)  
- 関連PR: ActiveRecord::Base.filter_attributes まわりの仕様導入 PR  
  - https://github.com/rails/rails/pull/55251  
- 関連ドキュメント:
  - Rails ガイド: セキュリティ > ログから機密情報をフィルタする (`config.filter_parameters`)  
  - Rails ガイド: Active Record Encryption（暗号化属性のフィルタ挙動・ログ出力に関する記述）

---


## [#56732](https://github.com/rails/rails/pull/56732) Add extension point to customize transaction for persistence methods {#pr-56732}

**マージ日**: 2026/2/9 | **作成者**: [@ipvalverde](https://github.com/ipvalverde)

1. 概要 (1–2文で)  
Rails の Active Record において、`save` / `destroy` などの永続化メソッドが内部で張る「暗黙のトランザクション」を、モデル単位でカスタマイズできる拡張ポイントが追加されました。これにより、トランザクション分離レベルやロールバック処理などを、`with_transaction_returning_status` をモンキーパッチせずに安全に制御できます。

---

2. 変更内容の詳細  

### 追加された拡張ポイント

`ActiveRecord::Transactions` 内で、永続化メソッドが使うトランザクション開始処理が、プライベートメソッドとして抽出されました（名前は説明からすると `implicit_persistence_transaction`）。  
モデル側でこれをオーバーライドすることで、トランザクションの張り方を細かく制御できます。

PR の説明にあるように、典型的なオーバーライド例は次のような形です:

```ruby
class Account < ApplicationRecord
  private
    def implicit_persistence_transaction(connection, &block)
      if connection.transaction_open?
        # 既にトランザクション内であれば、新たにトランザクションを張らない
        yield
      else
        # 親クラス（Active Record）のデフォルト実装を呼び出す
        super
      end
    end
end
```

ポイント:

- 引数:
  - `connection`: モデルが使っている DB コネクション (`ActiveRecord::ConnectionAdapters::AbstractAdapter` 派生)  
  - `&block`: 実際の保存／削除処理 + コールバックなどを含む本体

- デフォルト実装（`super`）は、従来 `with_transaction_returning_status` の中で直接書かれていた「保存処理をトランザクションでラップするロジック」で、  
  それが `implicit_persistence_transaction` というメソッドに移されたイメージです。

### なぜこの変更が必要か

以前から、トランザクション分離レベルを指定したい場合には:

1. 毎回明示的にトランザクションブロックでラップする:

   ```ruby
   Account.transaction(isolation: :read_committed) do
     account.save!
   end
   ```

2. もしくは `with_transaction_returning_status` をモンキーパッチして、そこに独自のトランザクション開始ロジックをねじ込む

という方法しかありませんでした。  
しかし後者は以下の問題があります:

- Rails 本体の実装が変わると簡単に壊れる（アップグレードに弱い）
- ロールバックや `throw` を含む細かい挙動に追従し続ける必要がある
- 他の gem との互換性で問題が出やすい

Rails には既に `ActiveRecord.with_transaction_isolation_level` という「ブロック範囲で isolation level を変える」API はありますが、これは「モデルの暗黙トランザクション設定」ではなく、「任意の処理を isolation level 付きで実行するため」のグローバルな仕組みです。

今回の PR では、「暗黙トランザクションをどう張るか」をメソッドに切り出し、モデルごとに安全にオーバーライドできるようにした、というのが本質的な変更点です。

### どう使えるかの具体例

#### 例1: あるモデルだけ常に特定の isolation level で保存する

```ruby
class Account < ApplicationRecord
  private
    def implicit_persistence_transaction(connection, &block)
      if connection.transaction_open?
        # 外側で isolation level が決まっている前提なのでそのまま
        yield
      else
        # このモデルの暗黙トランザクションは常に :read_committed
        connection.transaction(isolation: :read_committed) do
          yield
        end
      end
    end
end
```

#### 例2: 既にトランザクションが開いている場合には、新しいトランザクションを張らない

（PR の例）

```ruby
class Account < ApplicationRecord
  private
    def implicit_persistence_transaction(connection, &block)
      if connection.transaction_open?
        yield
      else
        super   # デフォルトのトランザクション処理
      end
    end
end
```

これにより、外側で大きなトランザクションを張っているときは、その中の `save` / `destroy` などが余分なトランザクションをネストしないようにできます。

#### 例3: ActiveRecord::Rollback の扱いをカスタマイズする

`implicit_persistence_transaction` の中で `begin ... rescue ActiveRecord::Rollback` を自前でハンドリングすることで、ロールバック発生時にログを出したり、特定フラグを立てたりといったカスタマイズも可能です。  
（PR 説明でも「AR::Rollback や throw を含むコールバック処理に対するカスタム処理」が例示されています）

---

3. 影響範囲・注意点  

- 影響範囲:
  - Active Record のトランザクション処理 (`with_transaction_returning_status` まわり) に、拡張ポイントとなるプライベートメソッドが一段挟まる形で実装変更されています。
  - デフォルト実装は従来と等価になるように作られているため、**何もオーバーライドしなければ既存アプリの挙動は変わりません**。
  - `activerecord/test/cases/transactions_test.rb` に追加されたテストから、この拡張ポイントの挙動（オーバーライドした場合の動作）がカバーされています。

- 注意点:
  - このメソッドは **private** であり、内部実装の一部でもあるため、「将来的なシグネチャ変更の可能性」には留意が必要です。ただし、あえて PR で明示的に抽出・命名されているので、Rails チームとしてもある程度は安定 API 的に扱う意図がうかがえます。
  - このメソッドをオーバーライドして `super` を呼ばない場合、デフォルトのトランザクション開始ロジック（ネスト時の join / save 成功・失敗時の戻り値処理など）を自分で面倒見る必要があります。挙動差が不具合につながりやすいので、必要箇所だけに絞って慎重に変更するべきです。
  - モデルごとにトランザクションポリシーがバラバラになると、アプリ全体の整合性やデバッグが難しくなり得ます。  
    「どのモデルにどのポリシーが適用されているか」をドキュメント化するのがおすすめです。

---

4. 参考情報 (あれば)  

- 対応する PR:  
  - 本 PR: `Add extension point to customize transaction for persistence methods` (#56732)  
  - 代替案として検討されていた PR: [#56673](https://github.com/rails/rails/pull/56673)  
    - そちらは「トランザクション作成の一部のパラメータをいじる」程度の柔軟性だったのに対し、本 PR は
      - トランザクションをスキップする
      - `ActiveRecord::Rollback` / `throw` を独自処理する
      など、より自由度の高いカスタマイズを可能にする設計になっています。

- 関連 API:
  - `ActiveRecord::Base.transaction(isolation: ...)`
  - `ActiveRecord.with_transaction_isolation_level`
  - `ActiveRecord::Transactions#with_transaction_returning_status`

---


## [#56739](https://github.com/rails/rails/pull/56739) Fix Logger documentation link in Active Record README {#pr-56739}

**マージ日**: 2026/2/9 | **作成者**: [@toilaloc](https://github.com/toilaloc)

1. 概要 (1–2文で)  
Active Record の README に記載されていた Ruby の Logger クラスへのリンクが 404 になっていたため、正しいドキュメント URL に差し替えた PR です。コード本体の挙動には一切影響せず、ドキュメントの品質向上のみを目的としています。

---

2. 変更内容の詳細  

- 対象ファイル: `activerecord/README.rdoc`
- 変更点はリンク URL のみで、1 行の置き換えです。

**変更前 (壊れているリンク)**  
```rdoc
https://docs.ruby-lang.org/en/master/Logger.html
```

**変更後 (有効なリンク)**  
```rdoc
https://ruby.github.io/logger/
```

もともと README では、「Active Record のログ出力には Ruby の `Logger` クラスを使う」といった文脈で公式ドキュメントへのリンクを貼っていましたが、その指し先が Ruby 公式サイトの `/en/master/` パスになっており、現在は 404 になっていました。

この PR では、Ruby 側のドキュメント構成変更に合わせて、`/en/master/` ではなく、`logger` ライブラリ専用のページ（`https://ruby.github.io/logger/`）に更新しています。これにより、開発者が README から直接 Logger のクラス・メソッド仕様を参照できるようになります。

---

3. 影響範囲・注意点  

- **影響範囲**  
  - Rails 本体の挙動、Active Record の API、ログ出力の仕組みなどには一切変更はありません。
  - 影響するのは、Active Record の README から Logger の仕様を確認するときに辿るリンクのみです。
- **注意点**  
  - README に記載された説明内容自体は変わっていないため、コード例や使い方に変更はありません。
  - Ruby のバージョンごとに Logger の細かい仕様が異なる場合がありますが、このリンク先は Ruby 標準添付ライブラリとしての Logger 一般のドキュメントです。特定バージョンにロックされているわけではない点に注意してください（以前の `/en/master/` のような「master ブランチ最新」ではなく、GitHub Pages 側の公開ドキュメントに紐づきます）。

---

4. 参考情報 (あれば)  

- 対象 README:  
  - https://github.com/rails/rails/tree/main/activerecord/README.rdoc
- 新しい Logger ドキュメント:  
  - https://ruby.github.io/logger/
- `Logger` クラスを利用する典型例（Rails 環境外の Ruby スクリプトでの例）:
  ```ruby
  require 'logger'

  logger = Logger.new($stdout)
  logger.level = Logger::INFO

  logger.info  "This is an info message"
  logger.error "This is an error message"
  ```
  Rails/Active Record では `ActiveRecord::Base.logger` などを通じて、この Ruby 標準の `Logger` を利用しています。

---


## [#56753](https://github.com/rails/rails/pull/56753) Upgrade to Dalli 5 {#pr-56753}

**マージ日**: 2026/2/8 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
このPRは、Railsが使用する Memcached クライアント gem「Dalli」をバージョン5系にアップグレードし、それに伴って `MemCacheStore` 向けのテストを Dalli 5 の振る舞いに合わせて修正したものです。併せて、直前の変更(#56721)や関連Issue(#56704)で発生していた不具合を解消しています。

---

2. 変更内容の詳細  

### 2-1. Dalli のバージョンアップ

- `Gemfile`  
  ```diff
  - gem "dalli", "~> 3.2"
  + gem "dalli", "~> 5.0"
  ```
  のように、Rails がテスト・開発用に利用する Dalli のメジャーバージョンを 5 系に変更しています（正確なバージョン指定は PR 本文に依存しますが、趣旨としては 5 系へのアップデート）。

- `Gemfile.lock`  
  - Dalli のバージョン表記と、その依存関係解決結果が更新されています。
  - これにより、CI・開発環境で bundle install した際に Dalli 5 が入るようになります。

### 2-2. MemCacheStore のテスト修正

変更は `activesupport/test/cache/stores/mem_cache_store_test.rb` に集中しており、内容としては:

- Dalli 5 での API 仕様や動作変更を反映する形で、期待値・モック・アサーションなどが修正されている
- 具体的には:
  - Dalli クライアントの戻り値・例外・メソッド呼び出し回数／引数などに関するテストを、Dalli 5 の挙動に合わせて調整
  - 非推奨となったオプションやメソッドを用いた古いテストケースを削除・置き換え
  - MemCacheStore が内部で利用する Dalli クライアントのインターフェース変更に伴い、テストのスタブ化・モック化の方法を更新

サンプル的にイメージすると、以下のような修正が入っている可能性があります（擬似コード）:

```ruby
# 旧: Dalli 3/4 系向けの想定
client = Dalli::Client.new("localhost:11211", namespace: "foo")
assert client.set("key", "value")

# 新: Dalli 5 に合わせてオプションや戻り値の扱いを調整
client = Dalli::Client.new("localhost:11211", **dalli_options)
assert_equal true, client.set("key", "value")
```

実際の差分では、これらが Rails の `ActiveSupport::Cache::MemCacheStore` 経由で呼び出される前提でテストされており、Dalli 5 の動作でテストが落ちないように細部が調整されています。

---

3. 影響範囲・注意点  

### 3-1. Rails 自体の挙動

- この PR は主に「依存ライブラリ（Dalli）のバージョンアップ」と「それに合わせたテスト修正」であり、Rails の公開 API (`ActiveSupport::Cache::MemCacheStore` の外部インターフェース) が大きく変わるものではありません。
- ただし、Memcached 用のキャッシュストアが内部で利用する Dalli の挙動が変わるため、**Dalli 特有の挙動に依存している場合には影響**が出る可能性があります。

### 3-2. アプリケーション側への影響・注意点

Rails アプリ側で以下のような場合は、挙動確認・修正が必要になる可能性があります:

- `dalli` を直接利用している (Rails の cache store 経由ではなく、アプリコードで `Dalli::Client` を明示的に生成している)  
  - Dalli 5 での非互換変更（オプションの削除・デフォルト値変更・メソッドの挙動変更など）に注意が必要です。
- `config.cache_store = :mem_cache_store, ...` で、Dalli 依存のオプションを細かく調整している  
  - 例: `expires_in`, `compress`, `pool_size` などに加え、Dalli 固有のオプションを渡している場合は、Dalli 5 で有効かどうかを確認してください。
- 古い Dalli バージョンでのみ存在したバグやワークアラウンドに依存している
  - Dalli 5 で修正された挙動により、「一見バグのような」変化が起きる可能性があります。

テスト・本番環境で Memcached を使っているプロジェクトは、Rails をこのコミット以降にアップデートした際、**キャッシュ周りの E2E テストやパフォーマンス、タイムアウト・接続エラー時の挙動**を確認しておくと安全です。

---

4. 参考情報 (あれば)

- この PR が修正しているもの:
  - https://github.com/rails/rails/pull/56721  
  - https://github.com/rails/rails/issues/56704  
  いずれも Dalli バージョン／MemCacheStore との互換性やテスト失敗などに関連していると考えられます。

- Dalli 5 の変更内容:
  - 正確な非互換点や新機能は Dalli 本体のリリースノート・README を参照してください。  
    例: GitHub `petergoldstein/dalli` の `CHANGELOG` や `README` など。

要するに、この PR は「Rails の Memcached サポートを Dalli 5 時代に対応させるための最低限のアップデートとテスト調整」であり、MemCacheStore ユーザーは今後 Dalli 5 系を前提とした動作になる点を認識しておく必要があります。

---


## [#56751](https://github.com/rails/rails/pull/56751) Pin dalli gem to version 4.x {#pr-56751}

**マージ日**: 2026/2/8 | **作成者**: [@yahonda](https://github.com/yahonda)

1. 概要 (1-2文で)  
Rails の依存関係として利用している memcached クライアント gem「dalli」を、5.x 系ではなく 4.x 系に固定（pin）する PR です。dalli 5.0.0 でバイナリプロトコルが削除されたことにより Rails のテストで `Dalli::Protocol::Binary` が見つからず落ちる問題を、一時的にバージョンを固定することで回避しています。

---

2. 変更内容の詳細  

### 何をしたか
- `Gemfile` の dalli の指定を「4 系に固定」するように変更
- それに伴い `Gemfile.lock` も 4.x を指すように更新

（PR 本文には直接のコード抜粋はありませんが、イメージすると以下のような変更です）

```ruby
# 変更前（例）
gem "dalli"

# 変更後（例）
gem "dalli", "~> 4.0"
```

これにより `bundle update dalli` を実行しても 5.0.0 以降ではなく、4.x 系の最新バージョンまでに制限されます。

### なぜ必要か
dalli 5.0.0 から「バイナリプロトコル」が削除され、内部クラス `Dalli::Protocol::Binary` が存在しなくなりました。一方、Rails の `MemCacheStore` 関連テストでは、テスト用の疑似サーバーとしてこのクラスを継承して利用しています:

```ruby
class UnavailableDalliServer < Dalli::Protocol::Binary
end
```

そのため、dalli 5.0.0 に上げてテストを走らせると、以下のような例外が発生します。

```text
uninitialized constant Dalli::Protocol::Binary (NameError)
  class UnavailableDalliServer < Dalli::Protocol::Binary
                                                ^^^^^^^^
```

この問題の本質的な対応（Rails 側のコードを dalli 5 系に追従するか等）は別 PR（https://github.com/rails/rails/pull/56721）で議論・対応中であり、それが決まるまで CI / 開発環境でのテストが落ちないよう、一時的に dalli を 4.x にピン留めした、という位置づけです。

---

3. 影響範囲・注意点  

- 影響範囲:
  - Rails 本体の依存としてインストールされる dalli が 4.x に固定されます。
  - Rails リポジトリ内で `bundle install` / `bundle update` した際に dalli 5.x へ自動更新されなくなり、テストスイートは引き続き dalli 4.x の API・挙動を前提に動作します。
- 注意点:
  - **dalli 5.x の新機能や変更点（メタプロトコルのみのサポートなど）を使った検証は、この PR 適用中の Rails ではできません**。ライブラリとしての Rails が dalli 5 に公式対応したとはまだ言えない状態です。
  - アプリケーション側で独自に `gem "dalli", ">= 5"` 等を指定している場合、Rails 本体の Gemfile とは別なので、アプリの Gemfile/Gemfile.lock にはこの PR の影響は直接は及びません。ただし、Rails のキャッシュストア実装やテストコードを参考にする場合、そこが dalli 4.x 前提である点に注意する必要があります。
  - このピン留めはあくまで「一時的なワークアラウンド」と明言されており、56721 のような本対応 PR がマージされれば、将来的に再び dalli 5.x に対応する変更が入る可能性が高いです。

---

4. 参考情報 (あれば)  

- 該当 PR（dalli 5 対応の本質的な修正議論）  
  - https://github.com/rails/rails/pull/56721
- dalli 5.0.0 の CHANGELOG  
  - https://github.com/petergoldstein/dalli/blob/main/CHANGELOG.md#500  
  - 「Removed binary protocol - The meta protocol is now the only supported protocol」と明記されており、`Dalli::Protocol::Binary` 削除の背景になっています。
- バイナリプロトコル削除の実装コミット  
  - https://github.com/petergoldstein/dalli/commit/b1f092045d98787763c965c0b49605090678e87c

---


## [#56730](https://github.com/rails/rails/pull/56730) Mark `ActiveRecord::Relation#values` as nodoc {#pr-56730}

**マージ日**: 2026/2/6 | **作成者**: [@p8](https://github.com/p8)

1. 概要 (1-2文で)  
`ActiveRecord::Relation#values` メソッドを Rails の公式ドキュメントから非公開（nodoc）扱いとする変更です。これにより、このメソッドは内部実装用として位置づけられ、アプリケーションコードからの利用は推奨されないことが明確になりました。

---

2. 変更内容の詳細  

- 対象: `activerecord/lib/active_record/relation.rb` の `ActiveRecord::Relation#values`  
- 変更点:  
  - `values` メソッドのドキュメントコメントに `:nodoc:` 指定を追加/変更し、「公開APIではない」と明示しました。（実装ロジック自体の変更はなし）

`values` は、Relation オブジェクトに対して設定されている各種クエリ句（where, order, joins, limit など）を内部的に保持するための `Hash` を返すメソッドです。PR本文では、`values_for_queries` と同様に「内部メソッド」とみなすべきだと説明されています。

イメージ的には、以下のような使い方が「できてしまう」メソッドですが、今回の変更により「やってはいけない領域」であることがより明確になります:

```ruby
relation = User.where(active: true).order(created_at: :desc)
internal_hash = relation.values
# => 本来は Rails 内部で使うことを想定した Hash 構造
```

この PR はあくまでドキュメント上の扱い（可視性）の変更であり、挙動や返り値の仕様を変更するものではありません。

---

3. 影響範囲・注意点  

- ライブラリ利用者 / アプリケーション開発者への影響
  - 挙動は変わらないため、すぐにテストが壊れるような実害はありません。
  - ただし、`Relation#values` を直接利用しているコードは、将来的な非互換変更（仕様変更・削除）の影響を強く受けやすい「内部API依存コード」であると再確認すべき状態です。
  - 今後の Rails バージョンで `values` の内部仕様変更／削除が行われても、変更は「公開APIの破壊的変更」とはみなされにくくなります。

- 既に `values` を使っている場合の代替検討例
  - クエリ構築状態を知るために:
    - できるだけ `where_values_hash` など、公開されているメソッドで代替できないか検討する
    - あるいは Relation 自体をそのまま組み立て・合成する設計に見直し、内部状態を直接覗かないようにする
  - 「values の Hash 構造に依存してロジックを書いている」場合、将来の Rails アップグレード時に壊れるリスクが高いため、早めのリファクタを検討した方が安全です。

- gem / ライブラリ作者への注意点
  - gem 内部で `ActiveRecord::Relation#values` に依存している場合、その gem は Rails の内部実装に強く結びついていることになります。
  - サポート対象の Rails バージョン範囲を狭める、あるいは内部実装依存を避ける方向で API 設計を見直すことが推奨されます。

---

4. 参考情報 (あれば)  

- この PR が示すポイント:
  - `ActiveRecord::Relation` は複雑な内部状態を持つクラスであり、その一部を表すメソッド（`values`, `values_for_queries` など）は「見えていても触らない」前提の内部APIであることが再確認された形です。
  - Rails 本体が nodoc 指定を進めている対象は、今後仕様が変わる・削除される可能性が比較的高いと考えておくとよいです。

- 類似の内部メソッド例:
  - `ActiveRecord::Relation#values_for_queries`
  - 各種 `_arel` 系メソッドなど、ドキュメントに出てこないメソッド群は基本的に内部APIと考えるのが安全です。

---


## [#56703](https://github.com/rails/rails/pull/56703) Fix ThroughReflection#association_primary_key with composite keys {#pr-56703}

**マージ日**: 2026/2/6 | **作成者**: [@felix-d](https://github.com/felix-d)

1. 概要 (1-2文で)  
`has_many :through` などで参照される `ThroughReflection#association_primary_key` が複合主キーを正しく扱えていなかった問題を修正するPRです。`primary_key: [:col1, :col2]` のような定義でも `_ids` リーダーメソッドが正しく動作するようになります。

---

2. 変更内容の詳細

### 何を直したか

対象メソッドは `ActiveRecord::Reflection::ThroughReflection#association_primary_key` です。  
これまでの実装は、`primary_key` が配列である場合を考慮せず、単純に `primary_key.to_s` を呼んでいました。そのため:

```ruby
# 例: ソース側関連
has_many :memberships,
  primary_key: [:tenant_id, :user_id]
```

のようなケースでは、`primary_key` が `[:tenant_id, :user_id]`（配列）になり、`to_s` によって `"[:tenant_id, :user_id]"` という1つの文字列に変換されてしまっていました。

このPRでは:

- `primary_key` が配列の場合: 各要素を `to_s` して配列にした `["tenant_id", "user_id"]` を返す
- `primary_key` が単一の場合: 従来どおり `primary_key.to_s` を返す

という分岐ロジックに変更されています。  
実装は `BelongsToReflection#association_primary_key` と同等の挙動になるように揃えられています。

### 何が問題だったか (エラー内容)

`has_many :through` + composite primary key な関連で自動生成される `_ids` リーダーが壊れており、次のようなエラーが発生していました。

```ruby
ActiveRecord::UnknownAttributeReference:
  Dangerous query method called with non-attribute argument(s): "[:col1, :col2]"
```

これは、内部的に `"[:col1, :col2]"` という“配列を文字列化したもの”がカラム名として扱われてしまい、ActiveRecord が「危険な非属性引数」とみなして例外を投げていたためです。

PRに含まれるテストでは、以下のような点がカバーされています:

- `ThroughReflection#association_primary_key` が配列・単一キー両方で期待どおりに文字列または配列の文字列に変換されること
- `has_many :through` で composite primary key を持つモデルに対して、`xxx_ids` リーダーが正常に動くこと
- sharding 関連のモデル (`sharded/blog`, `sharded/blog_post`) でもこの挙動が問題なく機能すること

テストモデルへの追加定義（例: `primary_key: [:shard_id, :id]` のような形）が行われ、実運用に近い形での回帰テストが増えています。

---

3. 影響範囲・注意点

- 影響を受けるのは:
  - `has_many :through` / `has_one :through` など ThroughReflection を使う関連
  - かつ、ソース側関連に `primary_key: [:col1, :col2]` のように複合主キーを指定しているケース
- 主な症状の変化:
  - 以前: `_ids` リーダメソッド（例: `project.user_ids`）呼び出しで `ActiveRecord::UnknownAttributeReference` が発生  
  - 以後: 正常に複合キーを扱うクエリが発行される
- 既存コードへの後方互換性:
  - 単一主キー (`primary_key: :id` など) の場合の戻り値は従来同様、`"id"` という文字列であり、挙動は従来と変わりません。
  - 配列を返すようになったのは、もともと壊れていたパス（Composite PK）なので、実質バグ修正であり互換性問題は極小です。
- カスタムで `ThroughReflection#association_primary_key` の結果を直接参照しているコードがもしあれば、「必ず文字列」という前提を置いていた場合に、複合キー時だけ「文字列配列」が返るようになる点には注意が必要です。

---

4. 参考情報 (あれば)

- この修正は `BelongsToReflection#association_primary_key` との挙動差異を埋める形で行われており、Rails内部のリフレクションAPIの一貫性が向上しています。
- エラーメッセージにある `Dangerous query method called with non-attribute argument(s)` は、Rails 7以降で導入された「非カラム値をwhere等に渡したときに警告する」仕組みからの例外であり、今回の修正はその保護機構との整合性もとっています。

---


## [#56742](https://github.com/rails/rails/pull/56742) Read from `ENV['REVISION']` if present {#pr-56742}

**マージ日**: 2026/2/6 | **作成者**: [@cocoahero](https://github.com/cocoahero)

1. 概要 (1-2文で)  
Rails のアプリケーションリビジョン取得ロジック (`Rails.application.revision`) が拡張され、`ENV["REVISION"]` が設定されていればそれを最優先で利用するようになりました。これにより、多くのデプロイプロバイダが採用している「環境変数でリビジョンを渡す」方式を Rails が素直にサポートします。

---

2. 変更内容の詳細 (サンプルコード含む)

### これまでの挙動
`Rails.application.revision` は、概ね次の優先順位でリビジョン（コミットハッシュ等）を決定していました。

1. `REVISION` ファイルが存在すれば、その内容
2. なければ `git rev-parse` コマンドで現在のコミットハッシュを取得
3. それでもダメなら `nil`（もしくは空）になるケース

### 変更後の挙動
今回の PR により、優先順位の一番上に `ENV["REVISION"]` が追加されました。

新しい優先順位は以下の通りです。

1. `ENV["REVISION"]` が設定されていれば、その値を返す
2. それが無ければ `REVISION` ファイルの内容を利用
3. それも無ければ `git rev-parse` で取得を試みる

※正確なメソッド名は `Rails.application.revision`（`Rails.app.revision` のように呼ぶこともある）が、この内部実装が今回修正された部分です。

### イメージとなるコード例

アプリケーションコード側からは、従来通り次のように使えます。

```ruby
Rails.application.revision
# 例: "3d2f1c7"
```

デプロイ設定側でリビジョンを環境変数に渡す例（Capistranoや各種PaaSを想定）:

```bash
# デプロイスクリプトなどで
export REVISION=$(git rev-parse HEAD)
RAILS_ENV=production bundle exec rails server
```

Rails アプリ内では、`ENV["REVISION"]` が優先されるため、Git リポジトリや `REVISION` ファイルがなくても、上記の値がそのまま `Rails.application.revision` に反映されます。

### テストとドキュメントの更新

- `railties/test/application/app_revision_test.rb`
  - `ENV["REVISION"]` が設定されている時にそれが優先されることを確認するテストが追加されています。
  - `REVISION` ファイルしかない場合や Git だけがある場合等、既存挙動との組み合わせもテストされていると考えられます。

- `guides/source/configuring.md`
  - 設定ガイド内の「アプリケーションのリビジョン」関連の記述が 1 行変更され、`ENV["REVISION"]` による指定方法が反映されています。

- `railties/CHANGELOG.md`
  - `Rails.application.revision` が `ENV["REVISION"]` を読むようになったことが、変更履歴として追記されています。

---

3. 影響範囲・注意点

### 影響範囲

- `Rails.application.revision` を利用している全てのコード（例: エラートラッキング、APM、フロントエンドへのバージョン情報埋め込み、ヘルスチェックエンドポイントなど）
- 特に以下のような環境で恩恵があります:
  - Git の履歴をコンテナイメージに含めていない（`git` コマンドもない）環境
  - `REVISION` ファイルを生成せず、デプロイ時に環境変数だけでリビジョンを渡している環境
  - Heroku や Render、その他 CI/CD で `REVISION` や `COMMIT_SHA` を ENV で渡すパターン

### 互換性・注意点

- **後方互換性**
  - `ENV["REVISION"]` が設定されていない場合の挙動は従来通り（`REVISION` ファイル → `git rev-parse`）のため、既存環境は基本的に影響を受けません。
- **優先順位の変化**
  - これまで `REVISION` ファイルを主として使っていた環境で、**同時に`ENV["REVISION"]` も設定している場合**は、**ENV の値が優先される**ようになりました。
  - CI やデプロイスクリプトで `REVISION` を無自覚に設定していると、意図せぬ値になる可能性があるため、値の整合性を確認した方がよいです。
- **値の形式は自由**
  - ENV に何を入れるかは規定されていないため、実運用では以下のようなポリシーをチーム内で決めておくとよいです。
    - Git のフル SHA / 短縮 SHA
    - バージョンタグ (e.g. `v1.2.3`)
    - デプロイID等（APM 連携などで使う）

---

4. 参考情報 (あれば)

- 実務的には、多くの PaaS / CI/CD プラットフォームで以下のような環境変数が用意されており、これらを `REVISION` に流用するケースが多いです:
  - GitHub Actions: `GITHUB_SHA`
  - GitLab CI: `CI_COMMIT_SHA`
  - CircleCI: `CIRCLE_SHA1`
- それらをマッピングする例:

```bash
# GitHub Actions の例
export REVISION="$GITHUB_SHA"
bundle exec rails db:migrate
bundle exec puma -C config/puma.rb
```

この PR により、こうしたパターンが Rails 標準の挙動により自然にサポートされるようになりました。

---


## [#56745](https://github.com/rails/rails/pull/56745) Bump Ruby version to 4.0.1 in devcontainer {#pr-56745}

**マージ日**: 2026/2/6 | **作成者**: [@yahonda](https://github.com/yahonda)

1. 概要 (1–2文で)  
Rails の開発用コンテナ(devcontainer)で使用する Ruby のバージョンが 4.0.0 などの旧バージョンから 4.0.1 に更新されました。ローカルで devcontainer を使って Rails を開発する際の実行環境が、公式 devcontainer リポジトリに追加された Ruby 4.0.1 に追従する形で整備された変更です。

---

2. 変更内容の詳細  

- 対象ファイル: `.devcontainer/Dockerfile`
- 変更内容: Ruby のバージョン指定を 1 行だけ差し替え

イメージとしては、Dockerfile 内の Ruby バージョン指定が以下のように変わったと考えられます（※PR本文からの推測・典型例）:

```dockerfile
- ARG RUBY_VERSION=4.0.0
+ ARG RUBY_VERSION=4.0.1
```

あるいは、ベースイメージを直接指定している場合は:

```dockerfile
- FROM ghcr.io/rails/devcontainer/ruby:4.0.0
+ FROM ghcr.io/rails/devcontainer/ruby:4.0.1
```

PR の説明にある通り、devcontainer 内で `ruby -v` を実行すると次のように報告されるようになります:

```bash
$ ruby -v
ruby 4.0.1 (2026-01-13 revision e04267a14b) +PRISM [aarch64-linux]
```

つまり、この PR は「VS Code Remote Container / Dev Containers」等で Rails を開発する際に立ち上がるコンテナの Ruby を 4.0.1 に揃えるためのバージョンアップです。

---

3. 影響範囲・注意点  

- 影響範囲
  - `.devcontainer` を利用している開発者:
    - 新しく devcontainer をビルドまたは再ビルドすると Ruby 4.0.1 が使われます。
    - 以前の devcontainer イメージをキャッシュしている場合も、再ビルドすると自動的に 4.0.1 に更新されます。
  - CI や本番環境:
    - この PR は `.devcontainer/Dockerfile` のみを変更しており、アプリケーション本体のコードや本番環境向け Dockerfile・Gemfile には触れていません。そのため、devcontainer を使っていない CI / 本番環境には直接の影響はありません。

- 注意点
  - Ruby 4.0.1 固有の挙動差:
    - 4.0.0 から 4.0.1 へのマイナーバグフィックスや内部実装の変更により、極めて稀にテストが落ちたり警告の出方が変わる可能性があります。
    - devcontainer 上でのみテスト結果が変わった場合、Ruby バージョン差異を疑う必要があります。
  - チーム開発時のバージョン差:
    - ローカルで devcontainer を使わない開発者が Ruby 4.0.0 など別バージョンを使っていると、環境差による微妙な挙動違いが起きる可能性があります。
    - `.ruby-version` や CI の Ruby バージョンも 4.0.1 に合わせることで、より一貫した開発環境を保てます。

---

4. 参考情報 (あれば)  

- PR が参照している関連 PR:
  - Ruby 4.0.1 対応が追加された devcontainer リポジトリの PR:  
    https://github.com/rails/devcontainer/pull/111  
    → Rails 公式 devcontainer イメージ側で Ruby 4.0.1 が利用可能になったことを受けて、本家 Rails リポジトリ側の `.devcontainer/Dockerfile` も追従した形です。

- 実開発での確認ポイント:
  - devcontainer を再ビルドして `ruby -v` が `4.0.1` になっているか
  - テストスイート・Rubocop などが問題なく動くか
  - チーム内の他の開発環境（ローカル Ruby / CI）と Ruby バージョンを揃えるかどうかの運用方針

---


## [#56741](https://github.com/rails/rails/pull/56741) Update Bundler to 4.0.6 {#pr-56741}

**マージ日**: 2026/2/5 | **作成者**: [@yahonda](https://github.com/yahonda)

1. 概要 (1-2文で)  
Bundler のバージョンを 4.0.4 から 4.0.6 に更新し、`bundle update <gem>` が正常に動作せず「Could not find compatible versions」で失敗していた問題を解消する PR です。Rails 本体のコードではなく、Gemfile.lock の Bundler バージョン指定のみを更新しています。

---

2. 変更内容の詳細  

- 変更ファイル  
  - `Gemfile.lock` の Bundler バージョンが `4.0.4` → `4.0.6` に 1 行だけ更新されています。

- 背景となる問題  
  Bundler 4.0.4 環境で、特定の gem（ここでは `dalli`）を `bundle update dalli` しようとすると、依存関係の解決時に失敗していました。

  エラーメッセージの要点:
  - `releaser` gem が `rake ~> 13.0` に依存
  - しかし `tools/releaser` というローカルソースに `rake ~> 13.0` が見つからない
  - そのため `releaser` が使えず、結果として依存解決全体が失敗し「Could not find compatible versions」となる

  つまり、「特定の gem だけアップデートしたい」という一般的なユースケースで、Bundler の依存解決ロジックに起因する不具合に当たっていました。

- Bundler 4.0.6 での挙動  
  Bundler を 4.0.6 に上げた後は、同じ環境・同じコマンドで以下のように正常に動作しています。

  ```bash
  # Bundler のアップデート
  gem update --system
  bundle update --bundler
  # => Updating bundler to 4.0.6.

  # 個別 gem の更新
  bundle update dalli
  # ...
  # Using dalli 4.3.0 (was 4.0.0)
  # Bundle updated!
  ```

  つまり、Bundler 4.0.6 には依存解決ロジックの修正（`https://github.com/ruby/rubygems/pull/9301`）が入っており、それを Rails リポジトリでも取り込んだ、という位置づけです。

- 方針的な補足  
  PR 作成者は「Bundler が出るたびに Rails でバージョンを追従するつもりはないが、今回は `bundle update` が壊れていたため例外的に上げた」と明言しています。  
  つまり「不具合回避のための最小限のバージョンアップ」という性格の変更です。

---

3. 影響範囲・注意点  

- 影響範囲  
  - Rails リポジトリで `bundle update <gem>` を実行した際の依存解決挙動が安定します。
  - Bundler 4.0.4 で発生していた、「ローカルソース経由の依存などが絡むと `Could not find compatible versions` で失敗する」ケースを回避できます。
  - Rails 本体の Ruby コードや動作仕様には一切変更がありません。

- 開発者視点での注意点  
  - Rails の開発に参加している場合、この PR マージ後の `Gemfile.lock` を使う前提であれば、手元の Bundler も 4.0.6 以上にしておくのが安全です。
    - 例: `gem update --system` または `gem install bundler -v 4.0.6`
  - Bundler 自体の仕様変更による副作用がないかを気にする場合は、Bundler のリリースノート・上記 PR を確認する価値がありますが、本 PR はそのうち「既知の不具合修正」を含むバージョンへの更新に留まっています。

---

4. 参考情報 (あれば)  

- この PR で取り込み対象となっている Bundler 側の修正:
  - https://github.com/ruby/rubygems/pull/9301

- この問題が発見されるきっかけとなった Rails issue:
  - https://github.com/rails/rails/issues/56704

- 当該 PR:
  - Rails PR #56741 “Update Bundler to 4.0.6”

---


## [#56729](https://github.com/rails/rails/pull/56729) Better handle cache deserialization errors {#pr-56729}

**マージ日**: 2026/2/5 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
Rails のキャッシュ復元（デシリアライズ）時に例外が発生した場合、それを「キャッシュミス」として扱うように振る舞いを明確化・強化した PR です。memcached などが切り詰められた（truncated）レスポンスを返すような稀なケースでも、アプリ本体が例外で落ちにくくなるようにしています。

---

2. 変更内容の詳細

※実際の差分を概念的に整理したものであり、行レベルの完全一致はしませんが、挙動の意図は正確になるように記述しています。

### 2-1. ActiveSupport::Cache::Coder の改善

`activesupport/lib/active_support/cache/coder.rb`

`Cache::Store` は「値を保存するとき」「値を取り出すとき」に、`Coder` を使ってシリアライズ／デシリアライズしています。この PR では以下の方針が明示的になりました。

- **デシリアライズに失敗したら、そのキーは「キャッシュミス」と見なす**
  - つまり、例外をアプリ層まで投げず、「キャッシュにヒットしなかった」ものとして扱う。

典型的には次のような形の処理になっています（イメージコード）:

```ruby
def load(payload)
  return unless payload

  begin
    deserialize(payload) # JSON/YAML/Marshal など
  rescue StandardError => error
    # ここで例外をキャッチしてキャッシュミス扱いにする
    ActiveSupport::Notifications.instrument("cache_deserialization_error.active_support",
      error: error,
      coder: self.class.name,
      payload: payload
    ) if defined?(ActiveSupport::Notifications)

    nil
  end
end
```

ポイント:

- これまでも一部のエラーは握りつぶされていましたが、
  - 「どの種類の例外をキャッチするか」
  - 「どう扱うか（ログ/通知など）」
  が整理され、**「デシリアライズに関するあらゆるエラーはミス扱い」**というポリシーがより一貫しました。
- 将来的な Ruby の警告や内部例外が出てもアプリの動作が止まりにくくなります。

### 2-2. SerializerWithFallback の調整

`activesupport/lib/active_support/cache/serializer_with_fallback.rb`

`SerializerWithFallback` は「新しいシリアライザと古いシリアライザの両方でデコードしてみる」ためのラッパです（例: JSON + Marshal のような組み合わせ）。

今回の修正で:

- 各シリアライザの `load` が例外を起こした場合も、「キャッシュミスとして扱う」というルールに合わせて動作するように整理されています。
- 具体的には
  - まず「優先シリアライザ」で `load` を試す
  - ダメなら「フォールバックシリアライザ」で `load` を試す
  - どちらも失敗したら **nil を返す（ミス扱い）**
- 例外は上位に伝播させず、内部で握りつぶして（もしくは通知だけして）nil を返す設計になります。

イメージコード:

```ruby
def load(payload)
  primary = @primary.load(payload)
  return primary unless primary.nil?

  @fallback.load(payload)
rescue StandardError => e
  # ここでも例外はミス扱いに統一
  nil
end
```

この結果、「新旧シリアライザのどちらの形式でもなかった」「途中で壊れたデータだった」ようなときは、確実にキャッシュミスとして動きます。

### 2-3. テストの追加・強化

`activesupport/test/cache/cache_coder_test.rb`  
`activesupport/test/cache/serializer_with_fallback_test.rb`

- キャッシュバックエンドが**切り詰められたデータ**や**壊れたデータ**を返すケースを模したテストが追加。
- 代表的なシナリオ:
  - デシリアライズ時に `TypeError` / `ArgumentError` / `StandardError` などが投げられる
  - 古いフォーマット・未知のフォーマット・中途半端なデータなど
- 期待結果:
  - アプリ側には例外が飛んでこず、
  - `read` の返り値は `nil` になる（キャッシュミスとして扱う）。

テストレベルで挙動が保証されたことで、「仕様」としての意味合いが強くなります。

### 2-4. tools/strict_warnings.rb の更新

`tools/strict_warnings.rb`

- strict モードでの Ruby 警告コントロール用スクリプトに微修正。
- デシリアライズ周り・例外周りの変更に伴って、警告や未使用変数などが出ないように調整していると思われます。
- 本質的には Rails 本体の品質確保用で、アプリ開発者への直接の影響はほぼありません。

---

3. 影響範囲・注意点

### 3-1. 影響範囲

影響を受けるのは主に以下です。

- ActiveSupport::Cache を使用しているすべてのキャッシュストア
  - `Rails.cache`（memcached, redis, file_store, memory_store などすべて）
  - カスタムの `Cache::Store` 実装の多くも `Cache::Coder` を使っている場合は影響
- `SerializerWithFallback` を使っているケース
  - Rails 内部、あるいは gem / アプリ独自のラッパがこのクラスを利用していれば対象

特に **memcached** のように、ネットワーク障害などで「切り詰められた値」「壊れた値」を返しうるストアに対して効果があります。

### 3-2. 実務上の挙動変化

- 以前: ある種のデシリアライズエラーがアプリケーションまで伝播し、`Rails.cache.read` が例外を投げる可能性があった。
- 以後: そうしたエラーは「キャッシュミス」として扱われ、`nil`（もしくは miss 相当の返り値）が返る。

これにより:

- **キャッシュ障害がアプリケーション障害に直結しにくくなる**
  - 「キャッシュは最悪なくても動く」が理想の設計ですが、この変更がその思想により沿った挙動になります。
- 壊れたキャッシュデータが残っていても、そのキーへのアクセスで例外が出続けることがなくなる。

### 3-3. 注意点 / 互換性

- もしこれまで「デシリアライズの失敗を検知して何か特別な処理をする」ために例外を拾っていたコードがある場合、
  - 今後は例外が発生せず、単に miss として扱われるため、
  - 挙動が変わる可能性があります（例外ハンドリングに依存していたロジックが動かなくなる）。
- 「キャッシュが壊れていることを明示的に検知したい」場合は、
  - ログ / 通知を発火するためのフック（ActiveSupport::Notifications など）が用意されているかを確認し、
  - そちらを監視する形に切り替える必要があります。
- 壊れたキャッシュデータがあってもアプリは落ちませんが、
  - キャッシュミス → 再計算 → 再保存
  のフローで自然回復する設計であることが前提です。
  - もし「常に同じ壊れた値を返すバックエンド」（例: 外部システムのバグ）があると、ミスが続きパフォーマンス劣化の原因になる可能性があります。

---

4. 参考情報 (あれば)

- PR 本体: https://github.com/rails/rails/pull/56729  
  - タイトル: *Better handle cache deserialization errors*  
  - 作者: @byroot
- 関連しそうなコード:
  - `ActiveSupport::Cache::Store`
  - `ActiveSupport::Cache::Coder`
  - `ActiveSupport::Cache::SerializerWithFallback`
- 運用上の推奨:
  - 例外は表に出なくなりますが、`cache_deserialization_error` のようなイベントがある場合は通知・ログにフックしておくと、バックエンドの不具合検知に役立ちます。
  - memcached / redis の監視とあわせて、キャッシュミスの急増も監視すると、デシリアライズエラーの多発を早期に気づけます。

---


## [#54982](https://github.com/rails/rails/pull/54982) Update Propshaft setup instructions in The Asset Pipeline guide [ci skip] {#pr-54982}

**マージ日**: 2026/2/5 | **作成者**: [@letsEstel](https://github.com/letsEstel)

1. 概要 (1-2文で)  
Railsガイド「The Asset Pipeline」の Propshaft セットアップ手順が、実行しても画面上の変化が分かりにくかった問題を解消するために改善されました。具体的には、チュートリアルの中でホームページとルート定義を追加し、Propshaft を使ったアセット読み込みが実際に確認できるようにしています。

---

2. 変更内容の詳細  

※PRはガイド (`guides/source/asset_pipeline.md`) だけの変更で、コード本体には手は入っていません。

主なポイントは以下の通りです。

### Propshaft セットアップ手順の補強

これまでのチュートリアルでは、Propshaft の導入コマンドなどを実行したあとに「何が見えるようになるのか」が不明瞭で、最後のコマンドを実行しても何も起きていないように感じられる、という問題がありました。

今回の修正で、**Propshaft を導入したあとに表示されるサンプルの Home ページと、そのルーティングを追加する手順**がガイドに追記されています。

典型的には以下のような流れが文章化されていると考えられます（コードは代表例であり、実際のガイドの抜粋イメージ）:

```bash
# Propshaft を使った新規アプリ作成（例）
bin/rails new blog --css=tailwind --asset-pipeline=propshaft
cd blog
```

続いて、トップページ用のコントローラとビューを作成する流れ:

```bash
bin/rails generate controller Home index
```

生成された `app/views/home/index.html.erb` に、アセットを利用した簡単な表示例（CSS や画像、JavaScript の確認）が書かれている形がガイド入りしていることが多いです。例えば:

```erb
<!-- app/views/home/index.html.erb -->
<h1>Hello, Propshaft</h1>
<%= image_tag "logo.png" %>
<%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
<%= javascript_include_tag "application", "data-turbo-track": "reload", defer: true %>
```

そして、ルート定義:

```ruby
# config/routes.rb
Rails.application.routes.draw do
  root "home#index"
end
```

これにより、`bin/rails server` を起動して `http://localhost:3000` にアクセスすると、  
- Propshaft 管理下の CSS / JS が読み込まれていること  
- 画像などのアセットが提供されていること  

をブラウザで確認できる、という「目に見えるゴール」がチュートリアルに明示されるようになりました。

変更差分としては、`asset_pipeline.md` において:

- Propshaft 導入後の説明に、Home ページ追加 & ルーティング設定の手順が 24 行ほど追加
- 既存の文言のうち、読者にとって分かりづらかった部分が 3 行ほど削除・差し替え

といった形になっています。

---

3. 影響範囲・注意点  

- **影響範囲**
  - コードベースではなく「ガイド（ドキュメント）」のみへの変更です。
  - 既存のアプリケーションの挙動には一切影響しません。
  - edgeguides / guides.rubyonrails.org を見ながら Propshaft を試すユーザーの学習体験が改善されます。

- **注意点**
  - 新しい Propshaft セットアップ手順に従う場合、  
    - コントローラ生成 (`rails generate controller`)  
    - ルート設定 (`root "home#index"`)  
    といったステップが前提になるため、**チュートリアル通りにやっていないと説明と挙動が合わない**可能性があります。
  - ガイドは Rails の edge バージョンに合わせた内容であることが多いため、古い Rails（Propshaft 対応前のバージョン）ではそのまま適用できない場合があります。

---

4. 参考情報 (あれば)  

- 該当ガイド:  
  - The Asset Pipeline（最新版 / edge）  
    https://edgeguides.rubyonrails.org/asset_pipeline.html  
- Propshaft プロジェクト:  
  - https://github.com/rails/propshaft  

この PR によって、Propshaft チュートリアルが「最後までやったのに画面上は何も変わらない」という状態から、**Home ページを表示してアセットが効いていることを確認できるチュートリアル**へ改善された、と理解しておくとよいです。

---


## [#56734](https://github.com/rails/rails/pull/56734) Make AM::AttributeSet::YAMLEncoder a Module {#pr-56734}

**マージ日**: 2026/2/4 | **作成者**: [@hmcguire-shopify](https://github.com/hmcguire-shopify)

1. 概要 (1-2文で)  
ActiveModel の `AttributeSet::YAMLEncoder` をクラスからモジュールに変更し、Active Record モデルごとに生成されていたエンコーダ用オブジェクトを不要にしてメモリ使用とスキーマリロード時の扱いを簡素化した変更です。`default_types` のキャッシュは既にモデルクラス側に持っているため、専用クラスをインスタンス化する必要がなくなったことをコード構造に反映しています。

---

2. 変更内容の詳細  

### 2-1. `ActiveModel::AttributeSet::YAMLEncoder` をクラス → モジュールへ

対象ファイル: `activemodel/lib/active_model/attribute_set/yaml_encoder.rb` (+4/-9)

- これまで:
  - `YAMLEncoder` はクラスとして定義され、Active Record モデルごとにインスタンスが生成される設計だったと考えられます。
  - インスタンスが持つ意味のある状態は「モデルの `default_types`」でしたが、それはすでにモデルクラス自身のインスタンス変数にキャッシュされていました。

- 変更後:
  - `YAMLEncoder` は **モジュール** に変更され、状態を持つ“オブジェクト”としてはもう使われません。
  - メソッドはモジュール関数 / モジュールメソッドとして提供され、必要な情報 (`default_types` など) は呼び出し側（モデルクラス）から引数として渡す形、もしくは呼び出し元のクラス経由で取得する形に整理されています。

イメージ的な変化（実際のコード断片イメージ）:

```ruby
# 変更前（イメージ）
class ActiveModel::AttributeSet::YAMLEncoder
  def initialize(model_class)
    @default_types = model_class.default_attributes # など
  end

  def dump(record)
    # @default_types を使ってレコードを YAML 化
  end
end
```

```ruby
# 変更後（イメージ）
module ActiveModel::AttributeSet::YAMLEncoder
  def dump(record, default_types:)
    # 引数経由で渡された default_types を使って YAML 化
  end
end
```

※実際のメソッド名や引数は若干異なる可能性がありますが、ポイントは「インスタンス変数に状態を持たず、モジュールとして stateless に近い構造にした」ことです。

---

### 2-2. Active Record 本体側での利用方法の調整

対象ファイル:
- `activerecord/lib/active_record/core.rb` (+2/-2)
- `activerecord/lib/active_record/model_schema.rb` (+0/-5)

Active Record 側では、今まで `YAMLEncoder` クラスを使っていた部分を、モジュールとして利用する形に合わせてリファクタリングしています。

代表的な変更点:

- `core.rb` 内で、以前は次のようなパターンがあったと推測されます:
  - モデルごとに `YAMLEncoder.new(self)` のようにインスタンスを生成し、YAML エンコード時にそのインスタンスを参照。
- 変更後は:
  - `YAMLEncoder` のインスタンスを保持するロジックを削除。
  - 代わりに、YAML エンコードが必要なときに `AttributeSet::YAMLEncoder` モジュールのメソッドを直接呼び出し、必要な情報 (`default_types` など) を引数やモデルクラス経由で渡すように変更。

`model_schema.rb` の削除行 (-5) から推測されるのは、「スキーマリロード時に `YAMLEncoder` インスタンスをクリアする」ようなコードが不要になった、という点です。  
モジュール化によってインスタンス状態をリセットする必要がなくなったため、その一連の管理コードを削除しています。

---

3. 影響範囲・注意点  

### 3-1. 公開 API への影響

- `ActiveModel::AttributeSet::YAMLEncoder` を **直接利用しているアプリやライブラリ** がある場合、以下に注意が必要です:
  - 「クラスとして `new` する」コードは動かなくなります。
    - 例: `encoder = ActiveModel::AttributeSet::YAMLEncoder.new(MyModel)` はエラーになる可能性が高いです。
  - モジュールとして `include` / `extend` して使う、あるいはモジュールメソッドを直接呼ぶように修正が必要です。

Rails 本体の想定としてはこのクラスは内部実装寄りであり、外部から new されることはあまり想定されていないはずですが、メタプログラミング的に内部 API に依存しているアプリでは互換性問題が出る可能性があります。

### 3-2. メモリ・パフォーマンス的な影響

- 以前は「テーブル（モデル）ごとに YAMLEncoder インスタンスを1つ持つ」設計だったものが、「インスタンス不要（0件）」になります。
- 大量のモデルを持つアプリケーションでは、わずかながらオブジェクト数削減・GC 負荷軽減の効果があります。
- より重要なのは、「スキーマリロード時に YAMLEncoder インスタンスをクリアする必要がなくなった」ことで、reloader 周りのロジックが簡素化され、バグの入り込み余地が減る点です。

### 3-3. スキーマリロード / 開発環境での挙動

- ActiveRecord::ModelSchema から `YAMLEncoder` に関連するリセット処理が削除されているため、開発環境でコードリロード / スキーマ変更を行う際にも、エンコーダ関連で古い状態が残るといった問題が起こりにくくなります。
- 既存の Rails アプリケーションで、YAML シリアライズされた属性（`serialize` など）を使っていても、通常は挙動上の違いは感じないはずです。内部での管理の仕方が変わっただけで、外から見た API は変わらないためです。

---

4. 参考情報 (あれば)

- PR: https://github.com/rails/rails/pull/56734  
- 関連しうる内部実装:
  - ActiveModel::AttributeSet と、その YAML シリアライズ機能
  - ActiveRecord::ModelSchema のスキーマキャッシュ・リロード周りのコード

この変更は主に「内部実装の整理 + パフォーマンス/メンテナンス性の改善」であり、通常のアプリケーションコードには非互換な影響はほとんどありません。ただし、`ActiveModel::AttributeSet::YAMLEncoder` をクラスとして new している場合のみ、モジュールとしての利用方法に書き換える必要があります。

---


## [#56733](https://github.com/rails/rails/pull/56733) Docs: Update pgAdmin name; fix foreign key wording {#pr-56733}

**マージ日**: 2026/2/4 | **作成者**: [@eglitobias](https://github.com/eglitobias)

1. 概要 (1-2文で)  
Active Record Migrationsガイドの文言を、現状に即した・より正確なものにするためのドキュメント修正です。  
具体的には、「PgAdmin III」という古い名称を「pgAdmin」に更新し、外部キーの例で誤解を招く「reviewers」を「authors」に修正しています。

---

2. 変更内容の詳細  

このPRで変更されたのは `guides/source/active_record_migrations.md` の2行のみです。

### (1) 「PgAdmin III」→「pgAdmin」への更新

- **Before**（イメージ）:  
  「…は PgAdmin III を使って確認できます」  
- **After**:  
  「…は pgAdmin を使って確認できます」

つまり、PostgreSQL用GUIクライアントの名称が、現在一般的に使われている「pgAdmin」に統一されました。  
Railsの機能やAPI自体には一切変更はなく、ツール名の表記のみの更新です。

### (2) 外部キーの説明における「reviewers」→「authors」

Active Record Migrationsガイドの、外部キー (foreign key) に関するサンプル説明文が修正されています。

- **Before**（誤解を招く例）:  
  「`books` テーブルの外部キー `author_id` は、`reviewers` テーブルへの参照です」  
- **After**（正しい関係を表す例）:  
  「`books` テーブルの外部キー `author_id` は、`authors` テーブルへの参照です」

上記はあくまでイメージですが、趣旨としては:

- `author_id` というカラム名から期待される参照先は `authors` テーブル  
- にもかかわらず、文中で `reviewers` が使われており、読者を混乱させる

という不整合があったため、それを正しいテーブル名 `authors` に修正しています。

この変更により、以下のような典型的な関連づけのイメージと文書の整合性が取れるようになります:

```ruby
class Book < ApplicationRecord
  belongs_to :author  # books.author_id → authors.id
end

class Author < ApplicationRecord
  has_many :books
end
```

---

3. 影響範囲・注意点  

- **影響範囲**
  - Rails本体のコード、API、挙動には一切変更はありません。
  - 影響するのは「Active Record Migrationsガイド」の日本語・英語問わずドキュメント内容のみです。
- **開発者への実務的な影響**
  - 既存アプリケーションのマイグレーションやスキーマに影響はありません。
  - 外部キーの説明がより直感的・一貫したものになるため、特にRails初心者や外部キー概念を学ぶ人にとって理解がしやすくなります。
  - PostgreSQLを使っている場合、「pgAdmin III」という旧称を見て混乱する可能性が減ります（現行のツール名「pgAdmin」で検索しやすくなる）。

注意点として、このPRはあくまで表記修正であり、

- 「pgAdmin」を使わなければならないという意味ではない
- 既にpgAdmin以外のツール（psql, DBeaver, TablePlus など）を使っている場合に何かを変える必要もない

という点に留意してください。

---

4. 参考情報 (あれば)  

- 該当PR: https://github.com/rails/rails/pull/56733  
- pgAdmin公式サイト: https://www.pgadmin.org/  
- Active Record Migrationsガイド（最新英語版）:  
  https://guides.rubyonrails.org/active_record_migrations.html

---


## [#56727](https://github.com/rails/rails/pull/56727) Use schema cache for primary key lookup during insert {#pr-56727}

**マージ日**: 2026/2/4 | **作成者**: [@matthewd](https://github.com/matthewd)

1. 概要 (1-2文で)  
Active Record が INSERT 時にプライマリキー名を特定する処理で、スキーマキャッシュ（`schema_cache`）を利用するようにした変更です。これにより、モデル側から PK 名が渡されないケースでも、都度 DB に問い合わせずキャッシュ済みのスキーマ情報から PK を引けるようになります。

---

2. 変更内容の詳細  

### 2-1. 背景となるコードパス  
通常の「モデル経由の INSERT」（`Model.create` など）の場合、Active Record は既に知っているプライマリキー名（`Model.primary_key`）を使って SQL を組み立てるため、この変更部分のコードパスはあまり通りません。  
一方で、より低レベルなインサート処理（`insert` 系メソッドを直接呼ぶようなケースなど）では、テーブルのプライマリキー名をアダプタ経由で問い合わせる必要があります。

従来は、この PK 名の解決にスキーマキャッシュが考慮されておらず、DB に依存した問い合わせ（`primary_key` 取得）を毎回行う可能性がありました。

### 2-2. 具体的な変更点  

**1) 抽象アダプタ (`abstract/database_statements.rb`) の変更**  
- INSERT 用のメソッド（`insert` / `insert_fixture` / それに類するメソッド）内で、プライマリキー名を解決する際に、`schema_cache` をまず見るように変更されています。  
- 擬似コードイメージ:

  ```ruby
  # 変更前（イメージ）
  primary_key = primary_key(table_name)

  # 変更後（イメージ）
  primary_key =
    if schema_cache&.primary_keys(table_name)
      schema_cache.primary_keys(table_name)
    else
      primary_key(table_name) # 従来の遅いパス（DB問い合わせ）
    end
  ```

  実際のコードは 1 行差分程度ですが、意味としては「PK 名を取得するときに、まず schema_cache を使う」という方向です。

**2) PostgreSQL アダプタ (`postgresql/database_statements.rb`) の変更**  
- PostgreSQL 固有の INSERT 実装（`insert` / `exec_insert` / RETURNING に絡む部分など）でも同様に、PK 名前解決に schema cache を使うよう 1 行レベルの変更が入っています。
- これにより、PostgreSQL では特に、`RETURNING primary_key` といった SQL を組み立てる際もキャッシュを活用できます。

**3) テストの追加・修正**

- `postgresql_adapter_test.rb`
  - PostgreSQL アダプタで、schema cache が PK 名の取得に使われることを検証するテストが追加。
  - 例として:
    - スキーマキャッシュをロードした状態で INSERT を実行
    - DB へのメタデータ問い合わせが行われない、もしくは `schema_cache` に格納されている PK 名が使われることを確認するテストが含まれていると考えられます。

- `sqlite3_adapter_test.rb`
  - SQLite3 アダプタでも同様に、INSERT 時に schema cache が参照されることを確認するテストが追加。
  - 既存テスト 1 行の調整（`-1`）と、新規のアサーションなど（`+9`）が加えられています。

- `schema_cache_test.rb`
  - `ActiveRecord::ConnectionAdapters::SchemaCache` 自体に対し、PK 名取得と INSERT の連携をより明示的に検証するテストが追加。
  - 「schema cache 上に PK 情報を持っているときに、INSERT の PK 解決がそれを使う」ことを保証する内容になっていると考えられます。

---

3. 影響範囲・注意点  

### 3-1. パフォーマンス面の影響  
- このコードパス自体は「高トラフィックではない」（PR 説明より）ため、アプリ全体のパフォーマンスが劇的に変わるケースは多くありません。
- ただし、以下のようなケースでは地味に効いてきます:
  - `insert` / `insert_fixture` / 独自ローレベル INSERT を多用している
  - テストツールやシード・バッチ処理などでアダプタの insert 系メソッドを直接叩いている
- こうした場面で、PK 名を得るために毎回 DB メタデータにアクセスしていた部分が、スキーマキャッシュで済むため、DB の負荷・レイテンシがわずかに改善します。

### 3-2. 正確性・互換性  
- スキーマキャッシュは通常、マイグレーション後などにリセット／再生成される運用が前提です。
- 今回は「既に他の場所で利用している schema_cache を、この PK 解決の経路でも利用する」だけなので、互換性リスクは非常に小さいです。
- スキーマが変更されたのに schema_cache を更新していない（= 元々危険な状態）場合、今回の変更により「INSERT の PK 名解決にも古い情報が使われる」ようになりますが、そもそもそうした状態はサポート外の運用と言えます。

### 3-3. カスタムアダプタへの影響  
- カスタムの DB アダプタで、`primary_key` 解決ロジックや schema_cache 統合を独自に実装している場合:
  - 今回の変更によって、抽象層から「schema_cache を優先する」という方針が強くなるので、実装がこれと矛盾していないかを確認した方がよいかもしれません。
- ただし、変更はかなり小さく、基本的には「抽象クラス側が schema_cache を見るだけ」なので、多くのアダプタには影響しないはずです。

---

4. 参考情報 (あれば)  

- PR タイトル: Use schema cache for primary key lookup during insert  
- PR 番号: #56727  
- 作者: matthewd  
- マージ日時: 2026-02-04T07:07:25Z  

関連して見ておくとよいもの:
- `ActiveRecord::ConnectionAdapters::SchemaCache` の実装:  
  - `primary_keys(table_name)` や `primary_key(table_name)` の振る舞い
- 各アダプタ(PostgreSQL / SQLite3 など)の `insert` / `exec_insert` 実装:  
  - PK 名をどのように受け取り・解決し・SQL に組み込んでいるか  
- マイグレーション後に schema_cache をリセット／再生成する運用フロー:  
  - Railsアプリでは `config.active_record.dump_schema_after_migration` や `schema_cache.yml` を利用している場合、その周辺の設定とあわせて確認すると理解しやすいです。

---


## [#56725](https://github.com/rails/rails/pull/56725) Fix broken links to YJIT documentation [ci skip] {#pr-56725}

**マージ日**: 2026/2/3 | **作成者**: [@ykttdn](https://github.com/ykttdn)

1. 概要 (1–2文で)  
Rails Guides（パフォーマンスチューニングガイド）内で、YJITドキュメントへのリンクが Ruby 本体側の変更により壊れていたため、正しい YJIT ドキュメント URL に更新した PRです。コードの挙動や機能には影響せず、ドキュメントのリンク修正のみを行っています。

---

2. 変更内容の詳細  

- 対象ファイル: `guides/source/tuning_performance_for_deployment.md`
- 変更内容:  
  - YJIT に関する説明箇所で参照している外部リンク（YJIT ドキュメント）を、Ruby 本体リポジトリ側の最新のドキュメント構成に合わせて修正。
  - 差分としては、既存リンク 3 箇所前後を、新しい URL に置き換える形で `+3/-3` の変更が行われています。

実際の差分は PR 本文には出ていませんが、文脈から考えると、例えば次のようなイメージの修正です（あくまでイメージです）:

```markdown
- 詳細は Ruby の YJIT ドキュメントを参照してください:
- https://docs.ruby-lang.org/en/master/YJIT.html
+ 詳細は Ruby の YJIT ドキュメントを参照してください:
+ https://docs.ruby-lang.org/en/master/yjit/README_rdoc.html
```

Ruby 本体側でのドキュメントパス変更が、下記 PR で行われており、それに追随した形です。  
- https://github.com/ruby/ruby/pull/12305  
- https://github.com/ruby/ruby/pull/15154  

---

3. 影響範囲・注意点  

- 影響範囲:
  - Rails Guides（特に「本番環境向けパフォーマンスチューニング」ガイド）を読む際に、YJIT に関する参照リンクが正しく機能するようになります。
  - アプリケーションコードや Rails 本体の挙動には一切影響なし（ドキュメントのみの変更）。
  - テストや CHANGELOG 更新は、チェックリスト上は考慮されていますが、実質は「ドキュメント変更のため不要」という扱いです。

- 注意点:
  - もし自分の社内 Wiki やブログなどで旧 YJIT ドキュメントの URL を参照している場合、この PR がヒントになるので、同様にリンク切れがないか確認するとよいです。
  - 将来 Ruby 側で再度ドキュメント構成が変わった場合も、Rails Guides が追随する必要があるため、YJIT ドキュメントの場所は Ruby 本体の変更に依存することを意識しておくとメンテ上有用です。

---

4. 参考情報 (あれば)  

- Ruby 本体側の関連 PR:
  - YJIT ドキュメントリファクタ/移動などを行った PR:
    - https://github.com/ruby/ruby/pull/12305  
    - https://github.com/ruby/ruby/pull/15154  
- Rails ガイド（edge版, 英語）  
  - Tuning Performance for Deployment (本 PR の対象ガイド):  
    - https://edgeguides.rubyonrails.org/tuning_performance_for_deployment.html  
- YJIT についての概要（Ruby 公式）  
  - https://github.com/ruby/ruby/tree/master/yjit

---


## [#56705](https://github.com/rails/rails/pull/56705) Fix AM::Serialization#read_attribute_for_serialization doc {#pr-56705}

**マージ日**: 2026/2/3 | **作成者**: [@p8](https://github.com/p8)

1. 概要 (1-2文で)  
ActiveModel::Serialization の `read_attribute_for_serialization` を、`alias` ベースの定義から通常メソッドとして定義し直すことで、公式ドキュメントに正しく掲載されるようにするとともに、引数を「キー1つ」に限定する PR です。挙動は従来と変えず、インターフェイスの明示化とドキュメント改善を目的としています。

---

2. 変更内容の詳細  

これまで `read_attribute_for_serialization` は、おそらく以下のように `send` の alias として定義されていました（実際のコードは概念的にこういう形です）:

```ruby
# 変更前（イメージ）
alias :read_attribute_for_serialization :send
```

この場合の問題点:

- **RDoc/YARD などのドキュメント生成ツールは、alias に対してはデフォルトではドキュメントを生成しない**ことが多い  
- そのため `read_attribute_for_serialization` が「ActiveModel::Serialization が提供する公式なフックメソッド」としてドキュメントに現れない  
- `send` を alias しているだけなので、**メソッドシグネチャ的には「任意個の引数」を受け取れるように見えてしまう**（実態としてはシリアライズ用途では1つのキーを渡すことを想定している）

この PR では、`read_attribute_for_serialization` を alias ではなく「明示的にメソッド定義」するように変更しています。

変更後のイメージ:

```ruby
def read_attribute_for_serialization(key)
  send(key)
end
```

ポイント:

- **メソッドとして明示的に定義**したことで、  
  - ドキュメント生成時に `read_attribute_for_serialization` がきちんと拾われる  
  - 引数名（`key`）や引数が1つであることがドキュメントに反映される
- 実装としては `send(key)` を呼び出しているだけなので、**動作上は従来とほぼ同等**  
- ただし、インターフェイスとして「キーを1つだけ受け取るメソッド」であることが**シグネチャ上も明確**になった

PR 説明文にもある通り:

> This also encodes the method signature to only accept a single key as argument, where `send` accepts any arguments.

つまり、元々 alias だったときは `send` の都合上「どんな引数リストでも理論上は通る」状態だったが、今回の変更で「キー1つだけを受け取る」メソッドとして仕様を固定化した、という位置付けです。

---

3. 影響範囲・注意点  

- **通常の ActiveModel / ActiveRecord モデル利用者への影響はほぼなし**  
  - 多くのケースでは `read_attribute_for_serialization(:attribute_name)` のように1引数で呼ばれており、その動作は変わりません。
- 影響があり得るケース:
  - `read_attribute_for_serialization` を**自前で多引数で呼び出していたコード**がある場合  
    - 例: `read_attribute_for_serialization(:foo, :bar)` のような使い方をしていた場合、今後は `ArgumentError` になる可能性があります（正式な想定外の使い方なので、今回の変更でより明確に不正と分かるようになったとも言えます）。
  - `read_attribute_for_serialization` を**オーバーライドしているクラス**が、シグネチャを `*args` などにしていた場合  
    - 互換性の観点では、`def read_attribute_for_serialization(key)` のように「単一キーを取るメソッド」として扱うのが望ましいです。  
- ドキュメント面:
  - 今後生成される Rails API ドキュメント上で `ActiveModel::Serialization#read_attribute_for_serialization` が表示されるようになり、**カスタマイズフックとして発見しやすく**なります。
  - シグネチャが明確になったことで、ライブラリアップデート時に IDE などでの補完や型サポート（RBS, Sorbet, etc.）にも寄与する可能性があります。

---

4. 参考情報 (あれば)  

- PR 本体: https://github.com/rails/rails/pull/56705  
- 関連する概念:
  - `ActiveModel::Serialization` モジュール: モデルオブジェクトをハッシュ化・JSON 化するための仕組み
  - `read_attribute_for_serialization`: シリアライズ時に各属性値を取得するためのフックメソッド。  
    モデル側でこのメソッドをオーバーライドすることで、「シリアライズ時だけ別の値を返す」といったカスタマイズが可能です。

---


## [#56724](https://github.com/rails/rails/pull/56724) Remove useless connection verification when pinning connection {#pr-56724}

**マージ日**: 2026/2/3 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
このPRでは、コネクションを「ピン留め」するときに毎回行っていた `verify!` 呼び出しを削除し、既に実装されている「最近使われたコネクションは再検証しない」ロジックに一元化することで、無駄なコネクション検証をなくしています。結果として、不要なクエリ（例: `SELECT 1`）の発行が減り、Active Record のコネクション管理がわずかに効率化されます。

---

2. 変更内容の詳細  

### 全体像
- 対象: ActiveRecord のコネクションプールおよび抽象アダプタ
- 主な変更:
  - コネクションを「pin（固定）」する際に行っていた明示的な `verify!` 呼び出しを削除
  - その代わり、アダプタ側の「最近使用されたコネクションは再検証しない」ロジックに任せるよう整理

#### 変更点1: connection_pool 側の明示的な `verify!` 呼び出しの削除
`activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb` から、コネクションを pin するときに呼んでいた `connection.verify!` が削られています。

イメージとしては、以下のようなコードパスが:

```ruby
def pin_connection
  connection = checkout
  connection.verify!  # ← これが削除された
  @pinned_connection = connection
end
```

のような形から、「チェックアウトしただけで即 `verify!` は呼ばない」挙動に変わった、という内容です（実際のメソッド名や詳細は簡略化していますが、意味合いとしてはこの通りです）。

元々 Active Record には以下のようなロジックが既にあります:
- コネクション取得時に「前回の使用時刻」等を見て、一定時間内に使われていれば `verify!` しない
- 逆に、長時間使われていない場合・接続断が疑われる場合などは `verify!` を行う

PR本文の "We now have some decent logic about not revalidating a connection that has been used recently" はまさにこの部分を指しています。  
したがって、pin 時の明示的な `verify!` はこのポリシーと二重になっており、「ほぼ常に不要なダブルチェック」になっていたため削除されています。

#### 変更点2: abstract_adapter 側のサポートコード追加
`activerecord/lib/active_record/connection_adapters/abstract_adapter.rb` には 6 行の追加があります。差分の狙いは、おそらく以下のような点です:

- 「最近使用されたコネクションは検証しない」ためのヘルパメソッドやタイムスタンプ管理の整理
- `verify!` 実装の一部を共通化、または条件付きでの実行に関するロジック強化

（具体的なメソッド名は差分全文がないため推測になりますが、PRメッセージから見て、`verify!` の呼び出し条件や「最近の使用」を判定するロジックに関わるコードである可能性が高いです）

この追加により、以下がより明確になります:
- 「いつ `verify!` すべきか」という判断をアダプタ側（および関連ヘルパ）に集約
- connection_pool 側は「検証ポリシーを知らない」薄い層になり、責務分離が改善

---

3. 影響範囲・注意点  

### 影響範囲
- 対象となるのは、**マルチ DB / シャーディング / connection switching** などで「コネクションをピン留めする」仕組みを使っているアプリケーションやライブラリです。
- また、独自アダプタや、connection_pool / adapter をモンキーパッチしている場合は影響受ける可能性があります。

### 実務的な影響
1. **無駄なヘルスチェックの減少**
   - これまで、ピン時に毎回 `SELECT 1` 的な検証クエリが走っていたケースが、不要な場合には実行されなくなります。
   - 大量のコネクション切り替えが発生する高トラフィック環境では、わずかながらもレイテンシ・DB 負荷が軽減される可能性があります。

2. **接続の信頼性**
   - 「長時間使われていないコネクションをピンした途端、壊れていた」というケースは、従来どおり抽象アダプタの `verify!` ロジックで検出される設計です。
   - PRの意図としては「不要な二重チェックを削っただけ」であり、「接続が切れているのに気づけなくなる」ような性質の変更ではないことが示唆されています。

3. **カスタムコードとの互換性**
   - もしアプリや gem 側が「ピン時に `verify!` が必ず呼ばれること」を前提にしたワークアラウンドを積んでいた場合、その前提は崩れます。
   - 典型的には、`verify!` をオーバーライドして何か副作用（ログ、メトリクス、独自リカバリ等）を期待していた場合などです。
   - こうしたコードは、「verify! の呼び出しタイミングは ActiveRecord の内部実装詳細であり、将来的に変わりうる」ものとして見直す必要があります。

### 注意点
- DB 接続まわりで「特定のタイミングでだけ接続チェックをしたい」といった特殊要件がある場合は、この変更後の `verify!` 呼び出しパターン（どこで、いつ実行されるか）を実際にログ等で確認しておくと安心です。
- 接続プール関連のバグやタイムアウト問題をデバッグする際には、「ピン時には自動で `verify!` されない」という前提でコードリーディングを行う必要があります。

---

4. 参考情報 (あれば)  

- 関連コード:
  - `activerecord/lib/active_record/connection_adapters/abstract_adapter.rb`
  - `activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb`
- 背景となる Active Record の挙動:
  - コネクションプールは各コネクションの「最終使用時刻」などを管理し、一定時間以上アイドルだった場合のみ `verify!` を呼ぶといったポリシーを持っています。
  - `verify!` 自体は各アダプタ（PostgreSQL, MySQL, SQLite 等）が実装し、通常は軽量なクエリ (`SELECT 1` 等) による疎通確認を行います。

このPRは、そうした既存ロジックを前提に、「ピン留め時のダブルチェックをやめてシンプルにする」リファクタリング／最適化、と理解するとよいです。

---


## [#56716](https://github.com/rails/rails/pull/56716) [ci skip] Correct typo in ActiveRecord changelog {#pr-56716}

**マージ日**: 2026/2/3 | **作成者**: [@coderhs](https://github.com/coderhs)

1. 概要 (1-2文で)  
このPRは、Active Record の CHANGELOG に記載されていたデータベース接続に関する文言のタイポ（誤記）を修正するものです。コードや挙動の変更は一切なく、ドキュメントのみの修正です。

2. 変更内容の詳細  
- 対象ファイル: `activerecord/CHANGELOG.md`  
- 変更内容は 1 行のテキスト修正のみで、データベース接続（connections）に関する説明文中のスペルミスや用語の誤りを正しい表記に直しています。  
- [ci skip] がタイトルに含まれている通り、ドキュメント変更のみのため CI を走らせない PR です。  

実際のコードや API のシグネチャ、設定オプションなどは一切変更されていません。  
CHANGELOG 上の例示コードや、接続管理に関する説明の「単語」レベルの修正に留まると考えてよいです。

3. 影響範囲・注意点  
- ランタイム挙動: 影響なし  
  - Active Record の接続管理やクエリ実行、トランザクション動作などには一切変更がありません。  
- マイグレーション・設定: 変更不要  
  - `database.yml` などの設定ファイルの見直しや、アプリケーション側のコード修正も不要です。  
- CHANGELOG の読み取り:  
  - 今後、該当バージョンの変更点を確認する際に、より正確な記述に基づいて挙動を理解できるようになります。  
  - 既に CHANGELOG を参照していた場合は、「あれ？文脈的におかしいな」と感じていた箇所が自然な表現に直っている程度の差分です。

4. 参考情報 (あれば)  
- このPRはドキュメント修正専用のため、Rails をバージョンアップしても今回の変更が原因で不具合が出ることはありません。  
- 実際の接続管理ロジックや API の仕様を確認したい場合は、CHANGELOG よりも以下を優先するとよいです:  
  - `activerecord` の公式ガイド: 「Active Record Basics」「Active Record Connection Handling」関連セクション  
  - 対象バージョンの API ドキュメント (`ActiveRecord::Base.connection`, `ActiveRecord::ConnectionAdapters` など)

---


## [#56683](https://github.com/rails/rails/pull/56683) Pass sql query to query log tags {#pr-56683}

**マージ日**: 2026/2/2 | **作成者**: [@fatkodima](https://github.com/fatkodima)

1. 概要 (1–2文で)  
Active Record の「クエリログタグ (query_log_tags)」に、実行される SQL 文字列がコンテキストとして渡されるようになりました。これにより、SQL 内容に応じた柔軟なタグ付けやデバッグ情報の付与が簡単に行えます。

---

2. 変更内容の詳細  

### 何が変わったか

従来 `config.active_record.query_log_tags` で設定した Proc には、主に「バックトレース 1 行分」などの情報が `context` として渡されていましたが、この PR により `context[:sql]` として「実際に実行される SQL 文字列」も渡されるようになりました。

これにより、SQL に基づいたタグ生成が可能になります。

#### 新しい使い方の例

PR 説明にある例:

```ruby
config.active_record.query_log_tags = [
  sql_length: ->(context) { context[:sql].length }
]
```

この設定により、各 SQL 実行時のログに「クエリ文字列の長さ」をタグとして付与できます。  
（実際のログのフォーマットは既存の query log tags の仕組みに従います。）

これと同様に、例えば以下のような応用が可能です:

```ruby
config.active_record.query_log_tags = [
  # レプリカ向けクエリかどうかを SQL から推定してタグ付け
  replica_candidate: ->(context) do
    sql = context[:sql]
    # 例: 特定テーブルへの読み取りはレプリカを想定、など
    sql.match?(/FROM\s+large_read_only_table/i)
  end,

  # 危険そうなクエリの検出用タグ
  uses_select_star: ->(context) do
    context[:sql].match?(/\bselect\s+\*/i)
  end,
]
```

### 実装面でのポイント

（ファイル差分の要約）

- `activerecord/lib/active_record/query_logs.rb`
  - クエリログタグを構築する際のコンテキストに `:sql` キーが追加された。
  - 既存のタグ生成フローは保ちつつ、SQL 文字列を渡すだけの後方互換的な拡張。

- `activerecord/test/cases/query_logs_test.rb`
  - `context[:sql]` が利用可能であることを検証するテストが追加。

- `activerecord/CHANGELOG.md`
  - Active Record の変更点として、本機能追加が記載された。

---

3. 影響範囲・注意点  

- **既存コードへの影響**
  - `context` に新たに `:sql` が追加されるだけで、既存の `query_log_tags` 設定はそのまま動作します。
  - 既存タグ定義が `context` のキーを前提にしていても、`sql` の追加は破壊的変更にはなりません。

- **セキュリティ / プライバシー**
  - `context[:sql]` をそのままログタグに出力すると、クエリ文字列（およびバインドされるパラメータ内容）がログに露出しやすくなります。
  - 個人情報や機密情報がプレーンテキストで SQL に含まれるケースでは、マスキングやハッシュ化などの処理を行うべきです。
    ```ruby
    config.active_record.query_log_tags = [
      sql_fingerprint: ->(context) do
        # SQL 全体は出さず、ハッシュにして特徴だけログに残す
        Digest::SHA256.hexdigest(context[:sql])
      end
    ]
    ```

- **パフォーマンス**
  - 非常に長い SQL や大量のクエリに対して、タグ計算が重くなるロジックを書くとオーバーヘッドになる可能性があります。
  - タグで SQL をそのまま出力するより、長さやハッシュ、正規表現による判定など、必要な情報に絞ることが推奨されます。

- **レプリカ切り替えデバッグの用途**
  - PR 動機にもある通り、「なぜこのクエリがレプリカに飛ばないのか」を調べるために、特定条件の SQL にだけ追加のバックトレース情報やフラグをログに埋め込む、といった使い方が容易になります。
  - 今までも `ActiveSupport::Notifications.subscribe("sql.active_record")` で実現可能でしたが、`query_log_tags` 設定だけで完結するようになり、アプリケーション設定として管理しやすくなります。

---

4. 参考情報 (あれば)  

- この PR: https://github.com/rails/rails/pull/56683  
- 関連 API:
  - `config.active_record.query_log_tags`
  - `ActiveSupport::Notifications` (`"sql.active_record"` イベント)  
- Active Record のクエリログタグに関するドキュメント（最新の Rails ガイド / API リファレンスを参照）

---


## [#56695](https://github.com/rails/rails/pull/56695) Use a single temporary connection pool when checking test schema {#pr-56695}

**マージ日**: 2026/2/2 | **作成者**: [@ilianah](https://github.com/ilianah)

1. 概要 (1-2文で)  
テスト用スキーマのチェック時に、1つの DB 設定につき「2つ」作られていた一時的なコネクションプールを「1つ」に統合し、同じプールを使い回すようにした PR です。これにより、テスト時のスキーマ・マイグレーション確認処理のオーバーヘッドが削減されます。

---

2. 変更内容の詳細  

### 背景 / 問題点

`ActiveRecord::Migration.load_schema_if_pending!` は、以下の2つの処理を行う際に一時的なコネクションプールを使っています:

1. スキーマが最新かどうかのチェック
2. 保留中マイグレーション（pending migrations）のチェック

従来は「それぞれで別々に一時プールを作成」していたため、  
**1 DB 設定あたり 2 回プール作成 → 2 回クリーンアップ**  
という無駄なコストが生じていました。

### この PR の変更点

この PR では、テスト用スキーマを確認する処理で:

- 1つの一時的なコネクションプールを作成
- そのプールを
  - スキーマのチェック
  - pending マイグレーションのチェック
  の両方で「再利用」するように変更しています。

主な変更点のポイント:

- `ActiveRecord::Migration.load_schema_if_pending!` 内のロジックを整理し、
  - これまで別々に呼んでいた「スキーマ更新の要否確認」と「pending マイグレーションの確認」を、
  - 同一プールを共有するフローにした。
- `ActiveRecord::Tasks::DatabaseTasks` 側のヘルパーメソッド（スキーマチェック関連）も、それに合わせて一時プールの扱いを調整。
- `activerecord/CHANGELOG.md` に、この挙動改善に関するエントリを追加。

※ PR タイトルと説明、および差分の規模（3ファイル / +50 -17）から判断すると、挙動を変えるというよりは「内部実装の効率化」が主で、API 仕様の変更は行っていません。

---

3. 影響範囲・注意点  

**影響する場面:**

- `ActiveRecord::Migration.load_schema_if_pending!` を通じて、
  - テストスイート起動時にスキーマ／マイグレーション状態をチェックする処理
  - 複数 DB（multiple databases）を利用しているプロジェクトのテスト環境
- 特に、DB 接続確立コストが高い環境（リモート DB、制限された CI リソースなど）では、わずかながら起動時間やリソース消費の改善が見込めます。

**注意点:**

- 1つの一時プールで2種類のチェックを行うため、もしアプリ側が「pending マイグレーションチェック時の接続状態」に過度に依存しているような特殊なコードを書いていた場合、動きに差異が出る可能性はありますが、通常の Rails アプリでは想定されません。
- 公開 API（メソッドシグネチャなど）には変更がない想定なので、既存コードの修正は基本的に不要です。
- コネクションプールのライフサイクル管理（作成・クリーンアップ）がまとめられているため、万一そこにバグがあるとテスト時の接続リークにつながる可能性はありますが、PR ではテストも追加・更新されている旨がチェック項目で示唆されています。

---

4. 参考情報 (あれば)  

- 対象メソッド:  
  - `ActiveRecord::Migration.load_schema_if_pending!`
  - `ActiveRecord::Tasks::DatabaseTasks` 内のスキーマチェック用ユーティリティ
- 変更ログ:  
  - `activerecord/CHANGELOG.md` に、テストスキーマチェック時の一時コネクションプール最適化に関する項目が追加されています。  
- 関連するコンテキスト:  
  - Rails のテスト起動時には、`load_schema_if_pending!` が走り、  
    - `db/schema.rb` または `db/structure.sql` が最新か
    - まだ適用されていないマイグレーションがないか  
    を確認します。  
  - この PR はその裏側の「接続管理」の最適化であり、テストスキーマ周りの一般的なワークフロー（`bin/rails db:test:prepare` など）には表面的な変更はありません。

---


## [#56715](https://github.com/rails/rails/pull/56715) [ci skip] Fix formatting of backtrace description in configuring.md {#pr-56715}

**マージ日**: 2026/2/2 | **作成者**: [@coderhs](https://github.com/coderhs)

1. 概要 (1-2文で)  
configuring.md ガイド内の backtrace 説明文に含まれていた不要な英単語 "the" を削除し、文章のフォーマット／文法を整えたドキュメント修正です。コードや挙動には一切影響せず、ドキュメントのみの微修正です。

2. 変更内容の詳細(あればサンプルコードも含めて)  
- 対象ファイル: `guides/source/configuring.md`  
- 変更点は1行のみで、backtrace に関する説明文中の「extra `the`」(余分な "the") を削除しています。  
- 例 (イメージ):  
  ```diff
- This option controls the the format of the backtrace output...
+ This option controls the format of the backtrace output...
  ```
  のように、英語として不自然な重複を取り除き、読みやすい表現に修正しています。  
- PR タイトルに `[ci skip]` が付いていることからも分かる通り、テストやビルドは不要な単純なドキュメント修正として扱われています。

3. 影響範囲・注意点  
- Rails 本体のコード、設定オプション、API 仕様などには一切変更はありません。  
- 既存アプリケーション、設定ファイル (`config/environments/*.rb` など)、実行時の backtrace 表示やログ出力の挙動にも影響はありません。  
- 影響は Rails ガイドの読み手 (特に backtrace / エラー出力の設定方法を確認する開発者) に限定され、文章がわずかに読みやすくなっただけです。

4. 参考情報 (あれば)  
- PR: https://github.com/rails/rails/pull/56715  
- 対象ガイド: Rails Guides「Configuring Rails Applications」(configuring.md)  
  - backtrace の設定方法や関連オプションを確認する際に参照するドキュメントの一部の文言修正です。

---


## [#56712](https://github.com/rails/rails/pull/56712) [ci skip] Fix typo in test/guide stategy -> strategy {#pr-56712}

**マージ日**: 2026/2/1 | **作成者**: [@coderhs](https://github.com/coderhs)

1. 概要 (1-2文で)  
Railsのテストコードとガイド文書内にあった「stategy / statetgy」というタイポが、正しい「strategy」に修正されたPRです。機能追加や挙動変更は一切なく、ドキュメントおよびテストの表記を整えるメンテナンス目的の変更です。

---

2. 変更内容の詳細  

### 対象ファイル
- `activerecord/test/cases/migration_test.rb`
- `guides/source/active_record_migrations.md`

両方とも、Active Record のマイグレーションに関連する箇所で、用語「strategy」の表記ゆれ・タイポがありました。

#### 具体的な修正例（イメージ）

```diff
- def test_migration_stategy
+ def test_migration_strategy
```

あるいはコメントや説明文中の:

```diff
- This statetgy is used when...
+ This strategy is used when...
```

といった形で、「strategy」という単語の綴りだけが修正されています。

PRタイトルに `[ci skip]` が付いているのは、テキスト修正のみでありテスト実行を省略する目的です（CIを走らせるほどの変更ではないため）。

---

3. 影響範囲・注意点  

- **ランタイムの挙動への影響なし**  
  実行コード（ライブラリ部分）は変更されておらず、テストコードとガイド文書のみの修正です。そのため、Railsアプリケーションの挙動やAPI仕様には影響しません。

- **テスト名・メッセージに依存している場合の注意**  
  もし `migration_test.rb` 内のテスト名やエラーメッセージ文字列に対して、外部ツール（例: テスト結果パーサ、メトリクス集計ツールなど）が「文字列完全一致」で依存している場合、名称変更によって影響を受ける可能性があります。ただし、通常のRailsアプリ開発ではほぼ問題にならない範囲です。

- **ドキュメントの可読性向上のみ**  
  ガイドを読んでいる際に、「stategy / statetgy」という誤記がなくなり、用語の一貫性が高まりました。学習・調査の際に混乱が減る程度の改善です。

---

4. 参考情報 (あれば)  

- PR: https://github.com/rails/rails/pull/56712  
- ガイド該当箇所（Active Record Migrations ガイド）:  
  https://guides.rubyonrails.org/active_record_migrations.html  
  ※ 本PRマージ後、英語版ガイド上の「strategy」に関連する説明文が正しいスペルで表示されます。

---


## [#56426](https://github.com/rails/rails/pull/56426) Make `rescue_from_handled.action_controller` store the full backtrace {#pr-56426}

**マージ日**: 2026/2/1 | **作成者**: [@zzak](https://github.com/zzak)

1. 概要 (1-2文で)  
`config.action_controller.rescue_from_event_backtrace` を `:array` に設定した場合、`rescue_from_handled.action_controller` 通知ペイロードにも「フルバックトレース（配列）」が載るようにした変更です。併せて、バックトレースから `Rails.root` を削った形で保持する処理や、関連設定・ガイド・テストの整備が行われています。

---

2. 変更内容の詳細

### 2-1. 新しい設定オプションの挙動

既存フラグ:  
- `config.action_controller.rescue_from_event_backtrace`

この設定を `:array` にすると、

- `action_controller.rescue`（既存）
- `action_controller.rescue_from_handled`（Rails 8.1 からの新イベント）

の両方の通知ペイロードで「フルバックトレース」が **配列形式** で格納されます。

以前は、`rescue_from_handled` 側ではこの設定が十分に反映されておらず、フルバックトレースがペイロードに入っていませんでしたが、この PR で揃えられています。

イメージ（通知ハンドラから参照される payload）:

```ruby
ActiveSupport::Notifications.subscribe("rescue_from_handled.action_controller") do |name, started, finished, unique_id, payload|
  # ここに full_backtrace が array として入るようになる
  backtrace = payload[:backtrace] # => ["app/controllers/users_controller.rb:10:in `index'", ...]
end
```

※ 実際のキー名は実装側に依存しますが、PR の文脈から「配列形式のバックトレース」が通知されることがポイントです。

### 2-2. `Rails.root` プレフィックスの削除

テストが追加されたと書かれている通り、バックトレースの各行から `Rails.root` を `delete_prefix` する処理が導入されています。

例:  
`/my/app/path/app/controllers/users_controller.rb:10:in 'index'`  
→ `app/controllers/users_controller.rb:10:in 'index'`

これにより、

- ログやイベントペイロードのパスがより短く読みやすくなる
- パスに環境依存要素（フルパス）が含まれにくくなる（オブザーバビリティツールやマルチ環境での集計に有利）

といった効果があります。

### 2-3. サブスクライバ・ログサブスクライバ周りの変更

以下のあたりが更新されています:

- `action_controller/structured_event_subscriber.rb`
- `action_controller/log_subscriber.rb`
- `action_controller/railtie.rb`

主な意図は:

- `rescue_from_handled.action_controller` イベントのペイロードに、`rescue_from_event_backtrace` 設定を反映させる
- バックトレースの整形（`Rails.root` の削除）を共通化しつつ、通知に適切な形で乗せる

### 2-4. 新フレームワークデフォルトと設定ガイド

次バージョン (8.2) のためのテンプレートが更新されています:

- `config/initializers/new_framework_defaults_8_2.rb.tt` に `rescue_from_event_backtrace` 関連の初期値やコメントを追加
- `guides/source/configuring.md` に該当オプションの説明を追加

これにより、新規アプリで `rails app:update` を行った時に、この設定項目とデフォルトの意味がガイド/initializer コメントを通じて明示されます。

---

3. 影響範囲・注意点

### 3-1. オブザーバビリティ（o11y）やログ集約への影響

- `rescue_from_handled.action_controller` イベントをすでに購読している場合、ペイロードの `backtrace` 関連の中身が変わる/増える可能性があります。
- 特に `:array` を指定している場合、**これまでより詳細なバックトレース情報が入る** ため:
  - ログ・APM・トレーシングツールのフィールドマッピングが変わる可能性
  - 取り込むデータ量が増える（バックトレース全行分）点に注意

作者も PR 説明で「既に o11y 側でこのイベントを取り込み始めた人がいるかもしれないため、互換性に配慮したい」と述べているため、**ペイロード仕様に依存しているコードがないか要確認**です。

### 3-2. ファイルパスの変化

`delete_prefix(Rails.root)` により、

- 以前フルパスを期待していた処理（例: 特定ディレクトリ配下のファイル検出を絶対パスで行う等）
- パスを正規表現でマッチさせていた処理

がある場合、**パス形式が変化しても問題ないか確認が必要**です。  
特に、SaaS APM などで「source map」や「code link」を張る仕組みを自前で組んでいる場合はパス解決ロジックを併せて見直してください。

### 3-3. 将来的な非推奨化の可能性

PR 説明文中で、作者はこのフラグを将来的に:

- deprecate（非推奨）し
- remove（削除）

することも視野に入れているとコメントしています。  
現時点では削除はされていませんが、以下のような流れが予想されます:

1. 8.1/8.2 でこの挙動を提供（今回の PR）
2. CHANGELOG とガイドで周知
3. 将来バージョンでフラグを非推奨化し、デフォルト挙動の一本化を検討

そのため、**長期的には「フラグに依存しない」かたちの運用**（例: 「常にフルバックトレースを想定する」）を前提に観測・ロギング側を設計すると、将来の変更の影響を減らせます。

---

4. 参考情報 (あれば)

- この PR:  
  https://github.com/rails/rails/pull/56426
- 関連 issue（Fixes: #56060 と言及あり）:  
  https://github.com/rails/rails/issues/56060
- 関連するイベント名:
  - `rescue_from_handled.action_controller`（Rails 8.1 で追加された新イベント）
  - `rescue.action_controller` / `rescue_with_handler.action_controller` 系の既存イベントとの仕様差に注意するとよいです。

運用上は、`config.action_controller.rescue_from_event_backtrace = :array` を有効にした状態で、実際に発火する通知ペイロードをローカルやステージング環境で `ActiveSupport::Notifications` からダンプして、中身を確認しておくことを推奨します。

---


## [#56454](https://github.com/rails/rails/pull/56454) Add `unique_by` option to `insert_all!` {#pr-56454}

**マージ日**: 2026/2/1 | **作成者**: [@chaadow](https://github.com/chaadow)

1. 概要 (1-2文で)  
`ActiveRecord::Relation#insert_all!` に `unique_by:` オプションが追加され、既に対応済みだった `insert_all` と同等のインターフェイスになりました。これにより、一括INSERT時に使用するユニークインデックスを `insert_all!` 側でも明示的に指定できるようになります。

---

2. 変更内容の詳細  

### 何ができるようになったか

これまで:

```ruby
# OK: insert_all は unique_by オプションを受け取れた
User.insert_all(records, unique_by: :index_users_on_email)

# NG: insert_all! には unique_by を渡せなかった
User.insert_all!(records, unique_by: :index_users_on_email) # ⇒ 引数エラーになる
```

このPR後:

```ruby
# insert_all! でも unique_by を指定可能に
User.insert_all!(
  [
    { email: "a@example.com", name: "Alice" },
    { email: "b@example.com", name: "Bob" }
  ],
  unique_by: :index_users_on_email
)
```

`unique_by:` で、複数存在し得るユニークインデックスのどれを「衝突判定」に使うかを明示できます。  
PostgreSQL や SQLite などの `INSERT ... ON CONFLICT` を持つDBで、複数ユニーク制約があるテーブルに対して挙動を制御する際に重要です。

### 実装的なポイント

- `ActiveRecord::Relation#insert_all!` のメソッド定義が更新され、キーワード引数で `unique_by:` を受け取るようになっています。
- 受け取った `unique_by:` は、内部で利用している `ActiveRecord::InsertAll` にそのまま渡されるだけで、実装としては既存機能の公開インターフェイスを揃えた形です。
- `activerecord/test/cases/insert_all_test.rb` に、`insert_all!` で `unique_by:` を指定した場合のテストが追加されています。
  - 例: 特定のユニークインデックス名や、列の組み合わせを指定しても動作することを確認。
- `activerecord/CHANGELOG.md` に、新しいオプションサポートとして追記されています。

### `unique_by` の指定方法（おさらい）

`unique_by` が取れる値は、既存の `insert_all` と共通です (DBごとにサポート内容は多少異なる):

- インデックス名（Symbol / String）  
  `unique_by: :index_users_on_email`
- カラム名の配列  
  `unique_by: %i[email account_id]`
- 一部アダプタでは unique constraint 名なども使用可能

これらは内部で `ON CONFLICT (columns...)` もしくは `ON CONSTRAINT constraint_name` に変換されます。

---

3. 影響範囲・注意点  

- **API の一貫性向上**  
  既に存在していた `insert_all` と `insert_all!` のオプション差分が解消されます。アプリ側で「普段は `insert_all` だが、場合によっては `insert_all!` に切り替える」といったケースでも、共通のオプションセットを使いやすくなります。

- **既存コードへの影響**  
  - シグネチャ変更は、「新しく `unique_by:` を受け付けるようになった」だけで、既存の呼び出しはそのまま動作します。
  - `unique_by:` というキーワード引数をすでにアプリ側で独自ラッパー等に渡していても、Rails本体がそれを受け取ってくれるようになるだけなので、互換性上の問題はほぼありません。

- **DBごとの挙動への依存**  
  - `unique_by:` の解釈は DB アダプタに依存します。指定したインデックス名／カラムが実際に存在しない場合は DBエラーになります。
  - もともと `insert_all` で使っていたロジックを `insert_all!` でもそのまま使えるようになっただけなので、DBまわりの制約は従来通りと考えてよいです。

- **使い分けの考え方**  
  - `insert_all` … 重複時に「スキップ」あるいは「更新」など、エラーを出さずに処理を進めたい場合。
  - `insert_all!` … 衝突・不正データなどがあれば**例外を投げてほしい**場合。  
  どちらでも `unique_by:` を揃って使えるようになったので、方針に応じてメソッドだけ切り替えればOKです。

---

4. 参考情報 (あれば)  

- 元PR: [#45317](https://github.com/rails/rails/pull/45317) — 今回はその再投稿版  
- 関連ドキュメント（英語）:  
  - Rails Guides – Active Record クエリインターフェイス / Bulk inserts (Rails edge / 7.x 以降)  
- 実際の構文の詳細・サポート状況は、`ActiveRecord::InsertAll` のクラスコメントおよび各アダプタ(例: `ActiveRecord::ConnectionAdapters::PostgreSQLAdapter`)の実装を参照すると理解しやすいです。

---


## [#56681](https://github.com/rails/rails/pull/56681) Make `ActionText::Attachable#read_attribute_for_serialization` public {#pr-56681}

**マージ日**: 2026/2/1 | **作成者**: [@sallyhall](https://github.com/sallyhall)

1. 概要 (1-2文で)  
`ActionText::Attachable` がオーバーライドしている `read_attribute_for_serialization` メソッドを `public` に変更し、元の `ActiveModel::Serialization` 側の可視性と揃えた PR です。これにより、`active_model_serializers` で `ActionText::Attachable` を含むモデルをシリアライズした際に発生していたエラーが解消されます。

---

2. 変更内容の詳細  

### 背景

- `ActiveModel::Serialization#read_attribute_for_serialization` は、以前は `protected/private` 相当の扱いでしたが、[過去の PR](https://github.com/rails/rails/pull/53042) により **public メソッド** になりました。
- 一方で `ActionText::Attachable` モジュールは、その `read_attribute_for_serialization` を **private メソッドとしてオーバーライド** していました（`private` な領域に定義していた）。
- その結果、「本体は public なのに、サブクラス/インクルード先で private 扱いにされている」という不整合が生じ、`active_model_serializers` がシリアライズ時にこのメソッドを呼び出そうとすると、可視性の不一致によりエラーが発生していました。  
  - 実際の不具合報告: https://github.com/rails-api/active_model_serializers/issues/2457

### この PR の変更点

主な変更は 3 点です。

1. **`ActionText::Attachable#read_attribute_for_serialization` の可視性を public に変更**
   - これまで `private` 節の中で定義されていた、あるいは実質的に private として扱われていたメソッドを `public` メソッドにしました。
   - 意図としては、「オーバーライド元である `ActiveModel::Serialization#read_attribute_for_serialization` の可視性 (public) と揃える」ための変更です。

   ざっくりイメージすると、以下のような変更が入っています（実際のコードは若干異なりますが、概念として）:

   ```ruby
   module ActionText
     module Attachable
       # 以前
       # private
       #
       # def read_attribute_for_serialization(attr)
       #   # ActionText の attachable 用の独自処理
       # end

       # 変更後（public として定義し直し）
       def read_attribute_for_serialization(attr_name)
         # ActiveModel::Serialization と整合する形で、
         # ActionText の属性取得ロジックを実装
         super
       end
     end
   end
   ```

   実際には `super` 呼び出しや ActionText 独自ロジックが含まれますが、「メソッドシグネチャは維持しつつ、可視性のみ public に揃えた」というのがポイントです。

2. **テスト追加 (`actiontext/test/unit/attachable_test.rb`)**
   - `read_attribute_for_serialization` が public として利用できること、およびシリアライズ時に問題なく動作することを確認するユニットテストが追加されています。
   - これにより、今後 `ActiveModel::Serialization` 側で仕様変更があっても、可視性の不整合が再発するのを防ぐ意図があります。

3. **CHANGELOG 更新 (`actiontext/CHANGELOG.md`)**
   - Action Text の CHANGELOG に「`ActionText::Attachable#read_attribute_for_serialization` を public にした」という変更が記載されました。
   - これは挙動に影響しうるため、利用者がバージョンアップ時に把握できるようにするためです。

---

3. 影響範囲・注意点  

### 主な影響範囲

- **影響を受けるのは、`ActionText::Attachable` を利用していて、かつ `ActiveModel::Serialization` / `active_model_serializers` と組み合わせているケース** です。
  - 例: `ActionText` を使ったモデル (`has_rich_text` を持つなど) を `ActiveModelSerializers` で JSON 化しているアプリケーション。

- これまで発生していた以下のような問題が解消されます:
  - シリアライザ内部で `object.read_attribute_for_serialization(:some_attribute)` のような呼び出しが行われる際、`ActionText::Attachable` を mixin したオブジェクトだけ `NoMethodError` や `private method 'read_attribute_for_serialization' called` などが出ていた問題。

### 互換性・副作用の可能性

- `read_attribute_for_serialization` が **public になった**ことで、
  - すでにこのメソッドを呼んでいたコードは、今後も問題なく動作し続けます（以前は private 呼び出しや `send` を使っていた場合でも、今後は堂々と public として呼べる）。
  - 新たにこのメソッドを外部から直接呼び出すことも技術的には可能になりますが、Rails の慣習上「シリアライズのためのフック」としての位置づけは変わりません。

- もしアプリ側で `ActionText::Attachable#read_attribute_for_serialization` を **独自にオーバーライドしていて、可視性を private にしていた** 場合は、  
  - Rails 本体側の変更と可視性がずれるため、`public` に揃えることが推奨されます。

---

4. 参考情報 (あれば)  

- 本 PR: https://github.com/rails/rails/pull/56681  
- `ActiveModel::Serialization#read_attribute_for_serialization` を public にした変更:  
  https://github.com/rails/rails/pull/53042  
- 発端となった不具合報告 (`active_model_serializers` 側):  
  https://github.com/rails-api/active_model_serializers/issues/2457

---


## [#56711](https://github.com/rails/rails/pull/56711) Fix code block for product show view the correct change in guide {#pr-56711}

**マージ日**: 2026/1/31 | **作成者**: [@arceus3115](https://github.com/arceus3115)

1. 概要 (1-2文で)  
このPRは、Railsガイド「Getting Started」の `getting_started.md` 内にある *product の show ビュー* のコード例を、実際の推奨実装と一致するように1行だけ修正したドキュメント変更です。アプリケーションコード自体には一切手を入れておらず、ガイドのコードブロックの齟齬を解消するためのものです。

---

2. 変更内容の詳細(あればサンプルコードも含めて)  

- 対象ファイル: `guides/source/getting_started.md`
- 変更行数: +1 / -1（1行差し替え）

PRタイトルの「Fix code block for product show view the correct change in guide」から分かる通り、**「Getting Started with Rails」ガイドの中で紹介されている `products#show` ビューのコード例**が、最新のガイドの文脈やその直前で説明している内容と食い違っていたため、そのコードブロックを正しい内容に合わせています。

典型的には、以下のような差分が想定されます（実際の差分イメージ）:

**修正前 (例)**

```erb
<!-- 古い、または説明と合っていない show.html.erb の例 -->
<p>
  <strong>Title:</strong>
  <%= @product.title %>
</p>

<p>
  <strong>Description:</strong>
  <%= @product.description %>
</p>
```

**修正後 (例)**

```erb
<!-- ガイド本文で説明している、最新の show.html.erb の例 -->
<p>
  <strong>Title:</strong>
  <%= @product.title %>
</p>

<p>
  <strong>Description:</strong>
  <%= @product.description %>
</p>

<p>
  <strong>Price:</strong>
  <%= number_to_currency(@product.price) %>
</p>
```

実際の差分は1行だけですが、ニュアンスとしては:

- ガイド本文でさきほど説明したコードと、  
- コードブロックに掲載しているサンプル

が一致するように、属性名・メソッド・ヘルパーの呼び出しなどを1行修正した、というタイプの変更です。

内容的には以下のような種類の補正である可能性が高いです:

- `@product` ではなく `product` を使っていた / その逆
- `link_to` の引数やパスヘルパーが、直前の章で変更したルーティングと噛み合っていない
- 表示するカラム名（`title` → `name` など）が現在のチュートリアルのモデル定義と一致していない
- ガイドで「こう書き換えましょう」と説明した後の最終版が、コードブロックに反映されていない

PR文の "Update the code block in getting_started.md to reflect changes in the show view." からも、「show ビューの正しい変更内容をガイドのコードブロックに反映させた」という意図であることが分かります。

---

3. 影響範囲・注意点  

- **影響範囲**
  - Rails本体の挙動やAPIには一切影響しません。
  - 「Getting Started」ガイドを見ながらアプリを作成しているユーザーが、  
    - ガイドの文章どおりの変更を行ったときに、  
    - コード例との不一致で混乱する  
    という問題を解消します。
  - これにより、**チュートリアルに従っても動かない / 表示が違う**といった初学者向けのハードルが下がります。

- **注意点**
  - ドキュメントのみの変更のため、アプリケーションコードやテストの更新は不要です。
  - Getting Started を教材として利用している場合（社内研修・勉強会資料など）、  
    - スクリーンショットや転記しているコードが旧バージョンに依存している場合は、それらをガイドの最新版に合わせて更新した方が混乱が少ないです。

---

4. 参考情報 (あれば)  

- 該当PR: https://github.com/rails/rails/pull/56711  
- Rails公式ガイド（Edge Guides / Getting Started）:  
  - https://edgeguides.rubyonrails.org/getting_started.html  
    （英語版。該当箇所は `products#show` のビューを作成・修正するセクション）

---

