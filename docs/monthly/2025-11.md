---
title: 2025年 11月
description: Ruby on Rails PR Digest - 2025年 11月にマージされたPRの要約
lastUpdated: 2025-11-26
---

# Ruby on Rails PR Digest - 2025年 11月

> このページは [rails/rails](https://github.com/rails/rails) リポジトリにマージされたPull Requestを自動的に収集し、AIで要約したものです。


## [#56231](https://github.com/rails/rails/pull/56231) Handle asynchronous raise in all of `reconnect!`

**マージ日**: 2025/11/25 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
`ActiveRecord::ConnectionAdapters::AbstractAdapter#reconnect!` 全体を、非同期的な例外（特に TimeoutError など）が途中で発生しても接続状態が中途半端に壊れないようにする変更です。  
以前の PR (#54738) で導入された「非同期例外から状態を保護する仕組み」を `reconnect!` メソッド全体に拡張しています。

---

2. 変更内容の詳細  

### 背景  
`reconnect!` は内部で以下のような処理を行いますが、いずれも時間がかかる可能性があり、タイムアウトや他スレッドからの割り込みなど「非同期に例外が飛んでくる」リスクがあります。

- `reconnect`（実際の DB 再接続処理）
- `reset_transaction`（トランザクション状態のリセット）
- `clear_cache`（クエリキャッシュなどのクリア）

これらの処理の途中で `Timeout::Error` などが発生すると、  
「接続は切れているのにトランザクション状態フラグだけ残っている」  
「キャッシュだけ消えていない」  
といった、中途半端で不整合な状態になり得ます。

以前の PR (#54738) では同様の問題の一部を解消しましたが、`reconnect!` 全体をカバーし切れていませんでした。

### 今回の変更のポイント  

- `AbstractAdapter#reconnect!` 内の  
  - `reconnect`  
  - `reset_transaction`  
  - `clear_cache`  
  といった一連の処理を、「非同期例外を安全に扱うための保護ブロック」で囲むようにリファクタリング。
- これにより、これらの処理中に `TimeoutError` などが発生しても、  
  - 内部状態が壊れない  
  - 少なくとも「壊れた状態で生き続ける」ことを防ぎ、次回以降の操作で致命的な不整合を起こさない  
  ようにしています。
- 実装的には、#54738 で導入された仕組み（例: アダプタ内部の「非同期例外から保護されたセクション」を扱うメソッド）を `reconnect!` 全体に適用する形になっています。

※ 実際のコードイメージ（簡略化・疑似コード）

```ruby
def reconnect!
  protect_from_async_raise do
    disconnect! if active?
    reconnect
    reset_transaction
    clear_cache!
  end
end
```

`protect_from_async_raise` は名前は仮ですが、  
- ブロックの途中で非同期例外が発生しても状態が壊れない／少なくとも壊れた状態を外に見せない  
ようにするためのラッパーです（内部的にフラグ管理・例外の再送出タイミングの制御などを行っていると考えられます）。

---

3. 影響範囲・注意点  

- 影響範囲  
  - ActiveRecord を使っているすべてのアプリケーションで、`reconnect!` を経由するケース（接続プールの再接続、自動再接続、あるいはユーザーコードから明示的に `reconnect!` を呼ぶ場合）に影響します。
  - 特に、`Timeout.timeout` で DB アクセスまわりをラップしているアプリケーションや、スレッド／Fiber ベースの割り込み・キャンセルを多用している環境で恩恵が大きいです。
- 挙動の変化  
  - 正常系の挙動は基本的に変わりません。  
  - 異常系（タイムアウト・割り込み発生時）に、  
    - 「接続状態・トランザクション状態・キャッシュ状態がより一貫した形で保たれる」  
    ようになります。
- 互換性上の注意点  
  - 「reconnect 中に TimeoutError が起きた場合に、たまたま前のコネクションやトランザクション状態が残っていた」というような、これまでの“偶然の”挙動に依存していたコードは、今回より安定した・明示的な失敗パターンに変わる可能性があります。
  - ただし、それは本来依存すべきでない不安定な挙動であり、今回の変更は実質的にバグフィックスの性質が強いものです。
- パフォーマンス  
  - 非同期例外保護のためのラッパー処理が増えますが、`reconnect!` 自体が頻繁に叩かれるメソッドではないため、一般的なアプリケーションではパフォーマンス影響はほぼ無視できると考えられます。

---

4. 参考情報 (あれば)  

- 元 PR: https://github.com/rails/rails/pull/56231  
- 関連 PR（今回のフォローアップ元）: https://github.com/rails/rails/pull/54738  
- 非同期例外・Timeout と ActiveRecord 接続に関する一般的な注意点:  
  - Ruby の `Timeout.timeout` はスレッドレベルの非同期例外を投げるため、DB 接続やトランザクションなど「途中で例外を投げられると壊れやすい処理」との相性が悪いことが知られています。  
  - Rails 本体側でこうした箇所を保護していく流れが続いており、本 PR もその一環です。

---


## [#56226](https://github.com/rails/rails/pull/56226) Address `Lint/UselessAssignment: Useless assignment to variable - sql.`

**マージ日**: 2025/11/25 | **作成者**: [@yahonda](https://github.com/yahonda)

1. 概要 (1-2文で)  
Rubocop の `Lint/UselessAssignment` に指摘されていた「使われていない変数 `sql` の代入」をテストコードから削除した PR です。機能的な挙動は変えず、静的解析の警告を解消するためのリファクタリングです。

---

2. 変更内容の詳細(あればサンプルコードも含めて)  

対象ファイル:
- `activestorage/test/controllers/representations/redirect_controller_test.rb`

Rubocop 実行時に以下の警告が出ていました:

```text
test/controllers/representations/redirect_controller_test.rb:96:7: W: [Correctable] Lint/UselessAssignment: Useless assignment to variable - sql.
      sql = event.payload[:sql]
      ^^^
```

この `sql` 変数は、その後どこでも参照されておらず、完全に「代入して終わり」になっているため、Rubocop が「無意味な代入」と判断しています。

PR では、この行をまるごと削除しています:

```ruby
# 変更前（該当箇所のイメージ）
ActiveSupport::Notifications.subscribed(callback, "sql.active_record") do
  # ...
  sql = event.payload[:sql]  # ← ここが削除された
  # （この後 sql は一切使われていない）
end
```

変更後は単純にこの代入行だけがなくなり、他のロジック・アサーションには一切手を入れていません。追加行はゼロで、削除行が 1 行のみです。

---

3. 影響範囲・注意点  

- **影響範囲**
  - 対象は Active Storage のコントローラテスト (`representations/redirect_controller_test`) のみです。
  - 実際のアプリケーションコード（プロダクションコード）には一切影響しません。
  - 変数 `sql` はもともと使われていなかったため、この削除によるテストの意味・検証内容の変化もありません。

- **注意点**
  - もし今後このテスト内で `event.payload[:sql]` を検証したくなった場合は、再度変数を導入するか、直接 `event.payload[:sql]` を参照する形でアサートを書く必要があります。
  - Rubocop の `Lint/UselessAssignment` は CI で必須チェックになっている可能性が高いため、同様に「代入して使っていない変数」は他のテストやコードでも警告の対象になります。  
    → デバッグ用の一時変数を残したままコミットしないよう注意が必要です。

---

4. 参考情報 (あれば)  

- 対応している Rubocop の警告: `Lint/UselessAssignment: Useless assignment to variable - sql.`
- 関連 PR: 「Follow up #56225」とあるため、#56225 で行った Rubocop 対応・関連リファクタリングの追加対応と考えられます。
- 変更統計:
  - 変更ファイル数: 1
  - 追加行数: 0
  - 削除行数: 1

---


## [#56225](https://github.com/rails/rails/pull/56225) Ensure variants are loaded and processed synchronously just once

**マージ日**: 2025/11/24 | **作成者**: [@rosa](https://github.com/rosa)

1. 概要 (1-2文で)  
Active Storage のプレビュー用バリアント生成処理で、同一リクエスト内なのにバリアントを二重にロード・生成しようとしていた問題を解消する PR です。`GET /rails/active_storage/representations/redirect` 時に、生成直後のバリアントをレプリカDBから再検索して失敗→再生成して競合する挙動を防ぎ、1回の同期処理で済むようにしています。

---

2. 変更内容の詳細  

### 背景となる問題

ActiveStorage で「プレビュー可能な blob」（動画・PDF など）に対して `GET /rails/active_storage/representations/redirect/...` を叩いたときの流れは大まかに以下です。

1. `ActiveStorage::Representations::BaseController` で `representation` をセットしつつ `processed` を呼んでバリアントを生成  
2. `ActiveStorage::Representations::RedirectController` で `@representation.url` を呼び、リダイレクト先 URL を取得

ところが内部実装上:

- `ActiveStorage::Blob#variant` を呼ぶたびに、新しい `ActiveStorage::VariantWithRecord` インスタンスが生成される  
- `VariantWithRecord#processed` は  
  - レコードがなければ **writer（primary）DB に手動で接続**して variant レコードを作成  
  - そのインスタンス内では `@record` をメモ化している
- しかし 2 回目 (`@representation.url` の中) は「別インスタンス」の `VariantWithRecord#processed` が呼ばれ、  
  - 今度は replica 側で variant レコードの存在チェックを行う
  - レプリカが primary と同期していないタイミングだとレコードが見つからない
  - その結果、プレビューを再ダウンロード＆再加工しようとし、最終的に「レコードは既に存在する」ため作成時に失敗（500）する

という構造的なレースコンディション／二重処理が発生していました。

### この PR の主な変更点

#### 1. `ActiveStorage::Preview` の変更

変更ファイル: `activestorage/app/models/active_storage/preview.rb (+1/-1)`

`ActiveStorage::Preview#image` から返すオブジェクト（内部的には `VariantWithRecord`）の扱いを変えることで、**同じリクエスト内では同じバリアントインスタンスを再利用**するようにしています。

具体的には（実際のコードはリンク先参照ですが概念的には）:

- 以前:
  - `preview.image` を呼ぶたびに `blob.variant(変換オプション)` を呼び、新しい `VariantWithRecord` インスタンスを生成
- 変更後:
  - プレビュー用のバリアントを一度生成したら、インスタンスをプレビューオブジェクト側に持たせて再利用する（= 2 回目以降は `VariantWithRecord` を作り直さない）

これにより、

- 1 回目 (`BaseController` での `processed` 呼び出し) で生成・保存された variant レコードを、そのままメモリ上の同一インスタンスから参照できる
- 2 回目 (`@representation.url`) では、**既に primary で作られたレコードを持っているインスタンス**に対して `processed` 相当の処理が走るため、レプリカ側で再検索し直す必要がなくなる

結果として:

- 変換処理（画像生成）は 1 回で済む
- DB への variant レコード作成も 1 回で済む
- レプリカ／プライマリ間のレイテンシに起因する 500 エラーを回避

という動作になります。

#### 2. テストの追加

変更ファイル: `activestorage/test/controllers/representations/redirect_controller_test.rb (+23/-0)`

`RedirectController` 経由のリクエストで、バリアントの処理が**一度だけ行われること**と、**同じインスタンスが再利用されることを前提とした挙動**をテストで担保しています。

想定されるテスト内容（要約）:

- `GET /rails/active_storage/representations/redirect/...` を叩いたときに:
  - プレビュー用バリアントが同期的に一度だけ生成される
  - 500 エラーにならず、正常にリダイレクト URL が返る
- （必要なら）2回目のリクエスト時は既存の variant レコードが利用される

---

3. 影響範囲・注意点  

- 対象: Active Storage を使っており、かつ「プレビュー可能な blob（動画・PDF 等）」の representation を `GET /rails/active_storage/representations/redirect` で配信しているアプリ
- 主な効果:
  - 同一リクエスト内でのバリアント二重生成が抑制される
  - レプリカDBを用いる構成で発生しうる、「variant レコードが primary にあるのにレプリカで見えない」ことによる 500 エラーが減る
  - CPU 負荷（画像/動画変換の重い処理）の削減、S3 等ストレージへの不要な再アップロード・再ダウンロードの削減
- 注意点:
  - 挙動としてはバグ修正であり、通常の利用では互換性問題はほぼない想定
  - もし独自に `ActiveStorage::Preview` や `VariantWithRecord` にパッチを当てている場合、インスタンスの再利用を前提としたこの変更と競合しないか確認が必要
  - 「同じ `preview.image` 呼び出しなのに毎回別インスタンスであること」を前提にしていた非常に特殊な実装がもしあれば、その前提は崩れます（一般的には想定外）

---

4. 参考情報 (あれば)  

- 該当コード（参考用）
  - `VariantWithRecord` のレコード作成時に writer に接続している箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/variant_with_record.rb#L57-L62
  - `VariantWithRecord` が `@record` をメモ化している箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/variant_with_record.rb#L56-L57
  - `Blob#variant` で毎回新しい `VariantWithRecord` を生成していた箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/blob/representable.rb#L100-L102
  - representation 設定＆処理呼び出し部分  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/controllers/active_storage/representations/base_controller.rb#L13-L14
  - redirect 用 URL 取得部分  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/controllers/active_storage/representations/redirect_controller.rb#L12

レプリカ構成で Active Storage のプレビュー周りの 500 が出ている場合、この修正を含む Rails バージョンへアップデートすることで改善が見込めます。

---


## [#56216](https://github.com/rails/rails/pull/56216) Fix TimeWithZone#xmlschema when wrapping DateTime local time

**マージ日**: 2025/11/24 | **作成者**: [@drymar](https://github.com/drymar)

1. 概要 (1-2文で)  
ActiveSupport::TimeWithZone#xmlschema が DateTime を「ローカル時刻」としてラップした場合に不正な ISO-8601 文字列を返してしまうリグレッションが修正されています。タイムゾーン部分の扱いを見直し、Time / DateTime どちらをラップしても正しいオフセット付き文字列を返すようになりました。

---

2. 変更内容の詳細 (サンプルコード含む)

### 問題の内容

`ActiveSupport::TimeWithZone` に `DateTime` をローカル時刻として渡した場合、`#xmlschema` が不正な文字列を生成していました。

```ruby
tz  = ActiveSupport::TimeZone["America/New_York"]
twz = ActiveSupport::TimeWithZone.new(nil, tz, DateTime.new(2025, 11, 7, 12))

twz.xmlschema
# 修正前の実際の出力
# => "2025-11-07T12:00:00+00:0-05:00"
```

本来期待されるのは以下のような、1つの正しいオフセットだけを持つ文字列です:

```ruby
"2025-11-07T12:00:00-05:00"
```

原因は、`TimeWithZone#xmlschema` の実装が「`time.iso8601` は末尾が常に `"Z"` で終わる」という前提で書かれていたことです。  
`Time` ではその前提が成り立つケースが多い一方、`DateTime#iso8601` はすでに `+00:00` や `-05:00` などのオフセットを含むため、末尾1文字だけ書き換える処理だと不正な文字列になっていました。

### 修正内容

`TimeWithZone#xmlschema` 内の置換ロジックを、末尾1文字ではなく「タイムゾーン部分全体」を対象に変更しています。

変更点の核心は以下の正規表現置換です:

```ruby
str.sub(/(Z|[+-]\d{2}:\d{2})\z/, formatted_offset(true, "Z"))
```

ポイント:

- `/ (Z | [+-]\d{2}:\d{2}) \z /`
  - 末尾 (`\z`) にある
  - `"Z"` もしくは `+HH:MM` / `-HH:MM` 形式のオフセット
  - をマッチ対象にする。
- `formatted_offset(true, "Z")`
  - TimeWithZone の持つタイムゾーン情報から正しいオフセットを算出し、`±HH:MM` 形式（もしくは 0 のとき `"Z"`）の文字列を返す既存のヘルパーメソッド。
- これにより、元の `Time` / `DateTime` インスタンスがどのようなオフセット表現を持っていても、末尾のタイムゾーン表現を TimeWithZone のタイムゾーンに基づく正しい値に「置き換える」ようになります。

### テストの追加

リグレッションテストが追加されています:

- `test_xmlschema_with_datetime_local_time`

テスト内容は概ね次のような形です（説明用の擬似コード）:

```ruby
tz  = ActiveSupport::TimeZone["America/New_York"]
twz = ActiveSupport::TimeWithZone.new(nil, tz, DateTime.new(2025, 11, 7, 12))

assert_equal "2025-11-07T12:00:00-05:00", twz.xmlschema
```

このテストにより、DateTime をローカル時刻として扱うケースで期待通りの ISO-8601 文字列が生成されることを確認しています。

---

3. 影響範囲・注意点

- 影響を受けるケース:
  - `ActiveSupport::TimeWithZone` に `DateTime` オブジェクトを「ローカル時間」として渡し、`xmlschema`（あるいは `iso8601` 相当のシリアライズ）を利用しているコード。
  - 特に、API レスポンスや XML/JSON シリアライズで TimeWithZone#xmlschema を直接/間接的に呼んでいる場合。
- 振る舞いの変化:
  - バグ修正のみであり、正しい ISO-8601 を生成する方向の変更です。
  - 既に壊れた形式（例: `"2025-11-07T12:00:00+00:0-05:00"`）が出ていた部分は、正しい形式（`"2025-11-07T12:00:00-05:00"`）に変わります。
  - それ以外の Time をラップした `TimeWithZone` については、元々期待されていた動作からの変更はありません。
- 互換性:
  - 仕様としては「正しい ISO-8601 出力をする」という意図に沿った修正なので、通常は後方互換性上の問題はありません。
  - ただし、もし既存システムが「バグったフォーマット」を前提にパースしているような極端なケースがあれば、その部分は修正が必要です（普通はありえない想定です）。

---

4. 参考情報 (あれば)

- 該当 issue: https://github.com/rails/rails/issues/56112  
- 修正対象メソッド:  
  - `ActiveSupport::TimeWithZone#xmlschema`（`activesupport/lib/active_support/time_with_zone.rb`）
- 回帰テスト追加箇所:  
  - `activesupport/test/core_ext/time_with_zone_test.rb`  
- 変更規模:  
  - ファイル数: 2  
  - 追加 14 行 / 削除 3 行  
  - CHANGELOG なしの小規模バグフィックスとして扱われています。

---


## [#56212](https://github.com/rails/rails/pull/56212) Fix CI eager loading when rake tasks invoke :environment before tests

**マージ日**: 2025/11/23 | **作成者**: [@trevorturk](https://github.com/trevorturk)

1. 概要 (1-2文で)
このPRは、テスト環境での`config.eager_load`設定が、CIにおいて`:environment` Rakeタスクがテスト前に実行されると意図した通りに機能しない問題を修正します。

2. 変更内容の詳細
- 問題点として、`config.eager_load = ENV["CI"].present?`が、`tailwindcss-rails`のようなGEMが`:environment`タスクをフックする際に`config.rake_eager_load = false`にオーバーライドされてしまい、CIでeager loadingが無効化されることが挙げられています。
- 本PRでは、`config.rake_eager_load = ENV["CI"].present?`を生成されるテスト環境のテンプレートに追加しました。これにより、Rakeタスクがテスト前に実行されても一貫してeager loadingが実行されるようになります。

3. 影響範囲・注意点
- この修正は、CI環境でのeager loadingが確実に実行されることを保証し、特にZeitwerkのエラーを持つアプリケーションが`bin/rails test`と`bin/rails zeitwerk:check`で異なる結果を出す問題を防ぎます。
- また、このアプローチはRakeタスク自体の取り扱いを変更するのではなく、設定ファイルを調整することで問題を解決しており、他の部分に影響を与えるリスクが少ないと考えられます。

4. 参考情報 (あれば)
- この問題は、Rakeタスクがデフォルトでeager loadingを無効化する方式から来ており、特にRails 5.1以前の遺産問題に関連しています。`rake_eager_load`の設定を利用することで、Rakeタスクにおいても一貫したロード順序を保つことができます。
- 詳細な再現手順と問題の背景については、作成者が用意した最小限の再現ケース（https://github.com/trevorturk/issue_56065）を参照してください。

---


## [#56218](https://github.com/rails/rails/pull/56218) [ci skip] Add extension schema to the db/schema.rb example.

**マージ日**: 2025/11/23 | **作成者**: [@kakudou3](https://github.com/kakudou3)

1. 概要
このプルリクエストは、Ruby on Railsの`db/schema.rb`のサンプルに拡張スキーマ情報を追加することで、Rails 8以降を使用するユーザーの混乱を避けることを目的としています。

2. 変更内容の詳細
`active_record_migrations.md`の`db/schema.rb`のサンプルコードが、スキーマダンパーの更新に伴って不足している情報を反映していなかったため、これを修正しました。具体的には、PostgreSQLの`plpgsql`が`pg_catalog`スキーマに存在することを反映し、サンプルを`pg_catalog.plpgsql`として更新しました。これはPostgreSQL 16.1で確認されています。

3. 影響範囲・注意点
この変更はドキュメントの更新に該当し、直接的なコードの変更やアプリケーションの動作には影響を及ぼしません。しかし、新しいRailsバージョンに移行するユーザーにとって有益であり、拡張機能の有効化に関する理解を助けます。

4. 参考情報
このPRは、以前のPR #52313で行われたスキーマダンパーの変更を反映する意図があります。また、PostgreSQL 16.1の拡張機能情報を参照しており、`plpgsql`が`pg_catalog`スキーマに属することが確認されています。

---

