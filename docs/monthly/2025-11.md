---
title: 2025年 11月
description: Ruby on Rails PR Digest - 2025年 11月にマージされたPRの要約
lastUpdated: 2025-11-25
---

# Ruby on Rails PR Digest - 2025年 11月

> このページは [rails/rails](https://github.com/rails/rails) リポジトリにマージされたPull Requestを自動的に収集し、AIで要約したものです。


## [#56225](https://github.com/rails/rails/pull/56225) Ensure variants are loaded and processed synchronously just once

**マージ日**: 2025/11/24 | **作成者**: [@rosa](https://github.com/rosa)

1. 概要 (1-2文で)  
Active Storage のプレビュー用バリアント生成処理で、同一リクエスト内なのにバリアントを二重にロード・生成しようとしていた問題を解消する PR です。`GET /rails/active_storage/representations/redirect` 時に、生成直後のバリアントをレプリカDBから再検索して失敗→再生成して競合する挙動を防ぎ、1回の同期処理で済むようにしています。

---

2. 変更内容の詳細  

### 背景となる問題

ActiveStorage で「プレビュー可能な blob」（動画・PDF など）に対して `GET /rails/active_storage/representations/redirect/...` を叩いたときの流れは大まかに以下です。

1. `ActiveStorage::Representations::BaseController` で `representation` をセットしつつ `processed` を呼んでバリアントを生成  
2. `ActiveStorage::Representations::RedirectController` で `@representation.url` を呼び、リダイレクト先 URL を取得

ところが内部実装上:

- `ActiveStorage::Blob#variant` を呼ぶたびに、新しい `ActiveStorage::VariantWithRecord` インスタンスが生成される  
- `VariantWithRecord#processed` は  
  - レコードがなければ **writer（primary）DB に手動で接続**して variant レコードを作成  
  - そのインスタンス内では `@record` をメモ化している
- しかし 2 回目 (`@representation.url` の中) は「別インスタンス」の `VariantWithRecord#processed` が呼ばれ、  
  - 今度は replica 側で variant レコードの存在チェックを行う
  - レプリカが primary と同期していないタイミングだとレコードが見つからない
  - その結果、プレビューを再ダウンロード＆再加工しようとし、最終的に「レコードは既に存在する」ため作成時に失敗（500）する

という構造的なレースコンディション／二重処理が発生していました。

### この PR の主な変更点

#### 1. `ActiveStorage::Preview` の変更

変更ファイル: `activestorage/app/models/active_storage/preview.rb (+1/-1)`

`ActiveStorage::Preview#image` から返すオブジェクト（内部的には `VariantWithRecord`）の扱いを変えることで、**同じリクエスト内では同じバリアントインスタンスを再利用**するようにしています。

具体的には（実際のコードはリンク先参照ですが概念的には）:

- 以前:
  - `preview.image` を呼ぶたびに `blob.variant(変換オプション)` を呼び、新しい `VariantWithRecord` インスタンスを生成
- 変更後:
  - プレビュー用のバリアントを一度生成したら、インスタンスをプレビューオブジェクト側に持たせて再利用する（= 2 回目以降は `VariantWithRecord` を作り直さない）

これにより、

- 1 回目 (`BaseController` での `processed` 呼び出し) で生成・保存された variant レコードを、そのままメモリ上の同一インスタンスから参照できる
- 2 回目 (`@representation.url`) では、**既に primary で作られたレコードを持っているインスタンス**に対して `processed` 相当の処理が走るため、レプリカ側で再検索し直す必要がなくなる

結果として:

- 変換処理（画像生成）は 1 回で済む
- DB への variant レコード作成も 1 回で済む
- レプリカ／プライマリ間のレイテンシに起因する 500 エラーを回避

という動作になります。

#### 2. テストの追加

変更ファイル: `activestorage/test/controllers/representations/redirect_controller_test.rb (+23/-0)`

`RedirectController` 経由のリクエストで、バリアントの処理が**一度だけ行われること**と、**同じインスタンスが再利用されることを前提とした挙動**をテストで担保しています。

想定されるテスト内容（要約）:

- `GET /rails/active_storage/representations/redirect/...` を叩いたときに:
  - プレビュー用バリアントが同期的に一度だけ生成される
  - 500 エラーにならず、正常にリダイレクト URL が返る
- （必要なら）2回目のリクエスト時は既存の variant レコードが利用される

---

3. 影響範囲・注意点  

- 対象: Active Storage を使っており、かつ「プレビュー可能な blob（動画・PDF 等）」の representation を `GET /rails/active_storage/representations/redirect` で配信しているアプリ
- 主な効果:
  - 同一リクエスト内でのバリアント二重生成が抑制される
  - レプリカDBを用いる構成で発生しうる、「variant レコードが primary にあるのにレプリカで見えない」ことによる 500 エラーが減る
  - CPU 負荷（画像/動画変換の重い処理）の削減、S3 等ストレージへの不要な再アップロード・再ダウンロードの削減
- 注意点:
  - 挙動としてはバグ修正であり、通常の利用では互換性問題はほぼない想定
  - もし独自に `ActiveStorage::Preview` や `VariantWithRecord` にパッチを当てている場合、インスタンスの再利用を前提としたこの変更と競合しないか確認が必要
  - 「同じ `preview.image` 呼び出しなのに毎回別インスタンスであること」を前提にしていた非常に特殊な実装がもしあれば、その前提は崩れます（一般的には想定外）

---

4. 参考情報 (あれば)  

- 該当コード（参考用）
  - `VariantWithRecord` のレコード作成時に writer に接続している箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/variant_with_record.rb#L57-L62
  - `VariantWithRecord` が `@record` をメモ化している箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/variant_with_record.rb#L56-L57
  - `Blob#variant` で毎回新しい `VariantWithRecord` を生成していた箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/blob/representable.rb#L100-L102
  - representation 設定＆処理呼び出し部分  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/controllers/active_storage/representations/base_controller.rb#L13-L14
  - redirect 用 URL 取得部分  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/controllers/active_storage/representations/redirect_controller.rb#L12

レプリカ構成で Active Storage のプレビュー周りの 500 が出ている場合、この修正を含む Rails バージョンへアップデートすることで改善が見込めます。

---


## [#56216](https://github.com/rails/rails/pull/56216) Fix TimeWithZone#xmlschema when wrapping DateTime local time

**マージ日**: 2025/11/24 | **作成者**: [@drymar](https://github.com/drymar)

1. 概要 (1-2文で)  
ActiveSupport::TimeWithZone#xmlschema が DateTime を「ローカル時刻」としてラップした場合に不正な ISO-8601 文字列を返してしまうリグレッションが修正されています。タイムゾーン部分の扱いを見直し、Time / DateTime どちらをラップしても正しいオフセット付き文字列を返すようになりました。

---

2. 変更内容の詳細 (サンプルコード含む)

### 問題の内容

`ActiveSupport::TimeWithZone` に `DateTime` をローカル時刻として渡した場合、`#xmlschema` が不正な文字列を生成していました。

```ruby
tz  = ActiveSupport::TimeZone["America/New_York"]
twz = ActiveSupport::TimeWithZone.new(nil, tz, DateTime.new(2025, 11, 7, 12))

twz.xmlschema
# 修正前の実際の出力
# => "2025-11-07T12:00:00+00:0-05:00"
```

本来期待されるのは以下のような、1つの正しいオフセットだけを持つ文字列です:

```ruby
"2025-11-07T12:00:00-05:00"
```

原因は、`TimeWithZone#xmlschema` の実装が「`time.iso8601` は末尾が常に `"Z"` で終わる」という前提で書かれていたことです。  
`Time` ではその前提が成り立つケースが多い一方、`DateTime#iso8601` はすでに `+00:00` や `-05:00` などのオフセットを含むため、末尾1文字だけ書き換える処理だと不正な文字列になっていました。

### 修正内容

`TimeWithZone#xmlschema` 内の置換ロジックを、末尾1文字ではなく「タイムゾーン部分全体」を対象に変更しています。

変更点の核心は以下の正規表現置換です:

```ruby
str.sub(/(Z|[+-]\d{2}:\d{2})\z/, formatted_offset(true, "Z"))
```

ポイント:

- `/ (Z | [+-]\d{2}:\d{2}) \z /`
  - 末尾 (`\z`) にある
  - `"Z"` もしくは `+HH:MM` / `-HH:MM` 形式のオフセット
  - をマッチ対象にする。
- `formatted_offset(true, "Z")`
  - TimeWithZone の持つタイムゾーン情報から正しいオフセットを算出し、`±HH:MM` 形式（もしくは 0 のとき `"Z"`）の文字列を返す既存のヘルパーメソッド。
- これにより、元の `Time` / `DateTime` インスタンスがどのようなオフセット表現を持っていても、末尾のタイムゾーン表現を TimeWithZone のタイムゾーンに基づく正しい値に「置き換える」ようになります。

### テストの追加

リグレッションテストが追加されています:

- `test_xmlschema_with_datetime_local_time`

テスト内容は概ね次のような形です（説明用の擬似コード）:

```ruby
tz  = ActiveSupport::TimeZone["America/New_York"]
twz = ActiveSupport::TimeWithZone.new(nil, tz, DateTime.new(2025, 11, 7, 12))

assert_equal "2025-11-07T12:00:00-05:00", twz.xmlschema
```

このテストにより、DateTime をローカル時刻として扱うケースで期待通りの ISO-8601 文字列が生成されることを確認しています。

---

3. 影響範囲・注意点

- 影響を受けるケース:
  - `ActiveSupport::TimeWithZone` に `DateTime` オブジェクトを「ローカル時間」として渡し、`xmlschema`（あるいは `iso8601` 相当のシリアライズ）を利用しているコード。
  - 特に、API レスポンスや XML/JSON シリアライズで TimeWithZone#xmlschema を直接/間接的に呼んでいる場合。
- 振る舞いの変化:
  - バグ修正のみであり、正しい ISO-8601 を生成する方向の変更です。
  - 既に壊れた形式（例: `"2025-11-07T12:00:00+00:0-05:00"`）が出ていた部分は、正しい形式（`"2025-11-07T12:00:00-05:00"`）に変わります。
  - それ以外の Time をラップした `TimeWithZone` については、元々期待されていた動作からの変更はありません。
- 互換性:
  - 仕様としては「正しい ISO-8601 出力をする」という意図に沿った修正なので、通常は後方互換性上の問題はありません。
  - ただし、もし既存システムが「バグったフォーマット」を前提にパースしているような極端なケースがあれば、その部分は修正が必要です（普通はありえない想定です）。

---

4. 参考情報 (あれば)

- 該当 issue: https://github.com/rails/rails/issues/56112  
- 修正対象メソッド:  
  - `ActiveSupport::TimeWithZone#xmlschema`（`activesupport/lib/active_support/time_with_zone.rb`）
- 回帰テスト追加箇所:  
  - `activesupport/test/core_ext/time_with_zone_test.rb`  
- 変更規模:  
  - ファイル数: 2  
  - 追加 14 行 / 削除 3 行  
  - CHANGELOG なしの小規模バグフィックスとして扱われています。

---


## [#56212](https://github.com/rails/rails/pull/56212) Fix CI eager loading when rake tasks invoke :environment before tests

**マージ日**: 2025/11/23 | **作成者**: [@trevorturk](https://github.com/trevorturk)

1. 概要 (1-2文で)
このPRは、テスト環境での`config.eager_load`設定が、CIにおいて`:environment` Rakeタスクがテスト前に実行されると意図した通りに機能しない問題を修正します。

2. 変更内容の詳細
- 問題点として、`config.eager_load = ENV["CI"].present?`が、`tailwindcss-rails`のようなGEMが`:environment`タスクをフックする際に`config.rake_eager_load = false`にオーバーライドされてしまい、CIでeager loadingが無効化されることが挙げられています。
- 本PRでは、`config.rake_eager_load = ENV["CI"].present?`を生成されるテスト環境のテンプレートに追加しました。これにより、Rakeタスクがテスト前に実行されても一貫してeager loadingが実行されるようになります。

3. 影響範囲・注意点
- この修正は、CI環境でのeager loadingが確実に実行されることを保証し、特にZeitwerkのエラーを持つアプリケーションが`bin/rails test`と`bin/rails zeitwerk:check`で異なる結果を出す問題を防ぎます。
- また、このアプローチはRakeタスク自体の取り扱いを変更するのではなく、設定ファイルを調整することで問題を解決しており、他の部分に影響を与えるリスクが少ないと考えられます。

4. 参考情報 (あれば)
- この問題は、Rakeタスクがデフォルトでeager loadingを無効化する方式から来ており、特にRails 5.1以前の遺産問題に関連しています。`rake_eager_load`の設定を利用することで、Rakeタスクにおいても一貫したロード順序を保つことができます。
- 詳細な再現手順と問題の背景については、作成者が用意した最小限の再現ケース（https://github.com/trevorturk/issue_56065）を参照してください。

---


## [#56218](https://github.com/rails/rails/pull/56218) [ci skip] Add extension schema to the db/schema.rb example.

**マージ日**: 2025/11/23 | **作成者**: [@kakudou3](https://github.com/kakudou3)

1. 概要
このプルリクエストは、Ruby on Railsの`db/schema.rb`のサンプルに拡張スキーマ情報を追加することで、Rails 8以降を使用するユーザーの混乱を避けることを目的としています。

2. 変更内容の詳細
`active_record_migrations.md`の`db/schema.rb`のサンプルコードが、スキーマダンパーの更新に伴って不足している情報を反映していなかったため、これを修正しました。具体的には、PostgreSQLの`plpgsql`が`pg_catalog`スキーマに存在することを反映し、サンプルを`pg_catalog.plpgsql`として更新しました。これはPostgreSQL 16.1で確認されています。

3. 影響範囲・注意点
この変更はドキュメントの更新に該当し、直接的なコードの変更やアプリケーションの動作には影響を及ぼしません。しかし、新しいRailsバージョンに移行するユーザーにとって有益であり、拡張機能の有効化に関する理解を助けます。

4. 参考情報
このPRは、以前のPR #52313で行われたスキーマダンパーの変更を反映する意図があります。また、PostgreSQL 16.1の拡張機能情報を参照しており、`plpgsql`が`pg_catalog`スキーマに属することが確認されています。

---

