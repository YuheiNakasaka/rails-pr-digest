---
title: 2025年 11月
description: Ruby on Rails PR Digest - 2025年 11月にマージされたPRの要約
lastUpdated: 2025-11-27
---

# Ruby on Rails PR Digest - 2025年 11月

> このページは [rails/rails](https://github.com/rails/rails) リポジトリにマージされたPull Requestを自動的に収集し、AIで要約したものです。


## [#56129](https://github.com/rails/rails/pull/56129) QueryIntent#execute!

**マージ日**: 2025/11/26 | **作成者**: [@matthewd](https://github.com/matthewd)

1. 概要 (1-2文で)
- ActiveRecord の `QueryIntent` が「どのアダプタに属しているか」を把握し、自身でクエリの前処理〜実行までを担えるようになりました。  
- これにより `QueryIntent#execute!` でクエリを実行し、結果の保持・取り出しまでを一貫してハンドリングする設計にリファクタリングされています。

---

2. 変更内容の詳細

### 全体像の変化

これまで:
- アダプタ (`PostgreSQLAdapter`, `Mysql2Adapter` など) 側のメソッド群が主導で、
  - SQL 組み立て
  - クエリ前処理（バインド、ログ、キャスティング準備など）
  - 実行 (`select_all`, `exec_query`…)
  を行い、`QueryIntent` は主に「意図（SQL, binds, cast モード）」を保持するだけの受動的なオブジェクトでした。

これから:
- `QueryIntent` が「自分はどのアダプタ上のクエリか」を知っており、そのアダプタに処理を依頼しながら、
  - 前処理
  - 実行 (`execute!`)
  - 結果の保存
  を主導する「ドライバー」役になります。
- アダプタ側の `select_all` / `exec_query` などは、`QueryIntent` を介して実行するスタイルに収斂していきます。

PR 説明にある通り、これで以下が可能になります:

> QueryIntent to `execute!`, storing the result for the caller to then request in whichever raw/cast form they prefer.

つまり `execute!` 一発でクエリを走らせ、呼び出し側は「生の結果」または「型変換済み結果」など、好きな形で結果を取り出せるようになる方向です。

---

### QueryIntent 側の主な変更点

`activerecord/lib/active_record/connection_adapters/query_intent.rb` (+107/-16):

※実際のコードは PR 本体を参照する必要がありますが、変更内容から想定できるポイントは以下です。

1. **アダプタインスタンスを保持**
   - これまでは「抽象的なクエリ情報（SQL, binds, type casts）」のみを持っていましたが、  
     今回から「どのアダプタで実行されるクエリか」を知るようになっています。
   - これにより、`intent.adapter` 経由で `adapter` に処理を依頼できます。

   イメージ:

   ```ruby
   intent = ActiveRecord::ConnectionAdapters::QueryIntent.new(
     adapter: connection,
     sql: "SELECT * FROM users WHERE id = $1",
     binds: [[nil, 1]]
   )
   ```

2. **`execute!` の追加**
   - `QueryIntent#execute!` が新設され、内部でアダプタに実行を委譲します。
   - 実装イメージ:

     ```ruby
     def execute!
       return @result if @executed

       # 前処理（バインド加工、ログ、スキーマキャッシュ確認など）をここで実施し、
       # 必要に応じて adapter のメソッドに処理を依頼する。
       @result = adapter.run_query(self) # 名前は実際とは異なる可能性あり
       @executed = true
       @result
     end
     ```

   - 重要なのは「結果を `QueryIntent` 内に保持する」ことです。  
     呼び出し側は `intent.raw_result`, `intent.cast_result` のように、後から好きな形でアクセスできるようになる準備が整います。

3. **クエリ前処理のロジックを吸収**
   - 以前はアダプタ側 (`database_statements.rb` 等) に散らばっていた「クエリ前処理」が `QueryIntent` 主導に寄せられています。
   - たとえば:
     - ログに出す SQL の生成
     - bind parameter のログ用整形
     - prepared statement の扱い
     - schema cache / prepared statement cache との連携
   - 「アダプタの実装差分」+「共通的なクエリ前処理」を、`QueryIntent` を中心とした API で統一していく設計です。

---

### database_statements / 各アダプタの変更

`activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb` (+88/-124) など、多くのアダプタファイルが差し替えられています。

共通する方向性:

1. **「直接 SQL を実行」→「QueryIntent ベースへ」**
   - 例えば `select_all(sql, name = nil, binds = [], prepare: false)` のようなメソッド内で、
     直接アダプタ固有の `raw_connection.exec` 相当を呼んでいた箇所が徐々に `QueryIntent` を介する形へ寄せられています。

   例: （あくまで構造イメージ）

   ```ruby
   def select_all(sql, name = nil, binds = [], prepare: false)
     intent = build_query_intent(sql: sql, name: name, binds: binds, prepare: prepare)
     intent.execute!
     intent.cast_result # ActiveRecord::Result を返す
   end
   ```

   ※「実行は intent に任せて、自分は結果の最終形式だけ選ぶ」形に寄る。

2. **adapter 固有ロジックは「QueryIntent から呼ばれる側」へ**
   - PostgreSQL / MySQL / SQLite 各アダプタの `database_statements.rb` / `schema_statements.rb` では、
     - クエリ生成
     - EXPLAIN
     - スキーマ dump など
     で SQL を組み立てるところは残しつつ、
     実行部分を `QueryIntent` がラップしやすいように抽象化しています。

3. **差分特徴 (ざっくり)**

   - `abstract_mysql_adapter.rb` / `mysql2/database_statements.rb`:
     - prepared statement モードや、`exec_query` / `select_rows` 周りで `QueryIntent` 対応。
   - `postgresql/database_statements.rb` / `postgresql_adapter.rb`:
     - PostgreSQL 固有の `async_exec` / `extended query` / prepared statement 等を `QueryIntent` 経由で扱いやすくするための整理。
   - `sqlite3/database_statements.rb` / `sqlite3_adapter.rb`:
     - 単純な `execute` / `query` 系を `QueryIntent` デザインに合わせてリファクタ。

---

### async queue への特記事項

PR 説明より:

> with the exception of the async queue, which needs a little extra handling, QueryIntent instances live and die all within a single `select_all`-or-similar method call on an adapter, so there's no lifetime issue

- 通常の同期クエリでは、`QueryIntent` は 1 回の `select_all` などの呼び出しの内部で生成〜破棄され、ライフタイムの問題は生じません。
- ただし「非同期キュー (async queue)」では、クエリが「スケジューリング → 後で実行」という流れになるため、
  - `QueryIntent` のライフサイクル
  - アダプタとの関連付け
  に追加のケアが必要になる、という前提が明示されています。
- 現時点では「例外として注意している」段階で、今後の PR で async まわりをきちんと `QueryIntent` 対応にする布石と考えられます。

---

3. 影響範囲・注意点

### ライブラリ開発者 / アダプタ拡張を書いている人向け

- **カスタムアダプタ / 自作 connection adapter** を実装している場合:
  - `database_statements.rb` 相当で `select_all` / `exec_query` などをオーバーライドしているコードは、`QueryIntent` 前提の新しいフローに追随する必要が出てきます。
  - 具体的には:
    - `QueryIntent` 生成に関与するメソッド
    - `QueryIntent` から呼ばれる実行メソッド（例: `run_query(intent)` のようなもの）が増えている可能性があるため、Rails 本体のアダプタ実装をベースに追従するのが安全です。

- **非同期クエリや独自のクエリキューを使っている場合**:
  - `QueryIntent` のライフタイムとアダプタとの紐付けに注意が必要です。
  - 「意図だけ先に作って後でアダプタに渡す」ような実装をしていると破綻する可能性があります（`QueryIntent` は「どのアダプタに属するか」を前提に動くため）。

### 一般的なアプリケーション開発者向け

- 公開 API (`ActiveRecord::Base.connection.select_all`, `Model.where(...).load` 等) の挙動は互換を保つように設計されています。
- この PR は主に内部実装の責務分担の変更であり、アプリコードから直接 `QueryIntent` を触っていなければ、基本的にはコード変更なしでそのまま動作することが期待されます。
- ただし、以下のようなケースでは注意:
  - `ActiveRecord::ConnectionAdapters` の内部クラス/メソッドを直接呼んでいた
  - 独自パッチで `database_statements.rb` のメソッドを再定義していた
  - `QueryIntent` を内部的に利用していた gem を使っている  
    → Rails のバージョンアップ時に、その gem 側の追従が必要になる可能性があります。

---

4. 参考情報 (あれば)

- 元 PR: #56129 「QueryIntent#execute!」
- フォローアップ元の PR: #55897  
  - こちらで `QueryIntent` 周りのリファクタ・導入が進められており、本 PR はその続きとして「実行元ドライバー化 & execute! 追加」が行われています。
- 変更対象主要ファイル:
  - `activerecord/lib/active_record/connection_adapters/query_intent.rb`
  - `activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb`
  - 各アダプタ:
    - `postgresql_*.rb`
    - `mysql*/database_statements.rb`
    - `sqlite3_*.rb`

内部 API レベルの変更が多いため、アダプタ実装や ActiveRecord 内部に踏み込む開発をしている場合は、`query_intent.rb` と `database_statements.rb` を重点的に確認しておくと理解が進みます。

---


## [#56237](https://github.com/rails/rails/pull/56237) Add langauge to code examples in asset pipeline guide [ci skip]

**マージ日**: 2025/11/26 | **作成者**: [@p8](https://github.com/p8)

1. 概要 (1-2文で)  
Asset Pipelineガイド内のコード例に、シンタックスハイライト用の「言語指定」を追加したドキュメント改善のPRです。機能追加や挙動変更はなく、Rails本体の動作には影響しません。

---

2. 変更内容の詳細  

- 対象ファイル:  
  `guides/source/asset_pipeline.md`

- 変更内容の趣旨:  
  ガイド中のコードブロックに、Markdown のフェンスコードの「言語ラベル」を付与することで、  
  - ガイドサイト上のシンタックスハイライトを有効にする  
  - 読みやすさ・理解しやすさを向上させる  
  という目的のドキュメントのみの変更です。

- 実際の変更イメージ（例）  

  具体的な差分はPR情報からは全文が分かりませんが、Rails Guidesでは典型的に以下のような変更になります。

  変更前（言語指定なし）:
  ````
  ```ruby
  # 言語指定なしの例（実際には何も書かれていないか、誤った指定）
  get "products/:id" => "catalog#show"
  ```
  ````

  変更後（言語指定あり）:
  ````
  ```ruby
  get "products/:id" => "catalog#show"
  ```
  ````

  あるいは Sprockets のマニフェスト例などでは:

  変更前:
  ````
  ```
  //= link_tree ../images
  //= link_directory ../stylesheets .css
  ```
  ````

  変更後:
  ````
  ```js
  //= link_tree ../images
  //= link_directory ../stylesheets .css
  ```
  ````

  実際にはこのPRでは2行追加・2行削除なので、上記のような「言語ラベルの追加」や「誤ったラベルの修正」が1〜2箇所行われたと考えられます。

---

3. 影響範囲・注意点  

- 実行コード・フレームワーク挙動への影響:  
  - なし（ドキュメントのみの変更）

- 影響範囲:  
  - Rails Guides（公式ドキュメント）のAsset Pipelineページの表示
  - 主に Web 上でガイドを読む際のコードハイライトが改善されます。

- 注意点:  
  - アプリケーション側の設定やコードを変更する必要はありません。  
  - ドキュメントの内容（コード例の意味・構成）は変わっておらず、視覚的な改善のみです。

---

4. 参考情報 (あれば)  

- PRのメタ情報から分かること:
  - タイトル: `Add langauge to code examples in asset pipeline guide [ci skip]`
    - `[ci skip]` から、CI を回さない軽微なドキュメント変更であることが明示されています。
  - 変更行数（+2/-2）から、1〜2箇所のコードブロックの言語指定を付与・修正しただけの非常に小さな変更であることが分かります。

- 関連ガイド:
  - Rails Guides: Asset Pipeline  
    https://guides.rubyonrails.org/asset_pipeline.html（英語版）  
    ※PRマージ後、ガイドが再生成されると、該当箇所のコードブロックのハイライトが改善されます。

---


## [#56231](https://github.com/rails/rails/pull/56231) Handle asynchronous raise in all of `reconnect!`

**マージ日**: 2025/11/25 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
`ActiveRecord::ConnectionAdapters::AbstractAdapter#reconnect!` 全体を、非同期的な例外（特に TimeoutError など）が途中で発生しても接続状態が中途半端に壊れないようにする変更です。  
以前の PR (#54738) で導入された「非同期例外から状態を保護する仕組み」を `reconnect!` メソッド全体に拡張しています。

---

2. 変更内容の詳細  

### 背景  
`reconnect!` は内部で以下のような処理を行いますが、いずれも時間がかかる可能性があり、タイムアウトや他スレッドからの割り込みなど「非同期に例外が飛んでくる」リスクがあります。

- `reconnect`（実際の DB 再接続処理）
- `reset_transaction`（トランザクション状態のリセット）
- `clear_cache`（クエリキャッシュなどのクリア）

これらの処理の途中で `Timeout::Error` などが発生すると、  
「接続は切れているのにトランザクション状態フラグだけ残っている」  
「キャッシュだけ消えていない」  
といった、中途半端で不整合な状態になり得ます。

以前の PR (#54738) では同様の問題の一部を解消しましたが、`reconnect!` 全体をカバーし切れていませんでした。

### 今回の変更のポイント  

- `AbstractAdapter#reconnect!` 内の  
  - `reconnect`  
  - `reset_transaction`  
  - `clear_cache`  
  といった一連の処理を、「非同期例外を安全に扱うための保護ブロック」で囲むようにリファクタリング。
- これにより、これらの処理中に `TimeoutError` などが発生しても、  
  - 内部状態が壊れない  
  - 少なくとも「壊れた状態で生き続ける」ことを防ぎ、次回以降の操作で致命的な不整合を起こさない  
  ようにしています。
- 実装的には、#54738 で導入された仕組み（例: アダプタ内部の「非同期例外から保護されたセクション」を扱うメソッド）を `reconnect!` 全体に適用する形になっています。

※ 実際のコードイメージ（簡略化・疑似コード）

```ruby
def reconnect!
  protect_from_async_raise do
    disconnect! if active?
    reconnect
    reset_transaction
    clear_cache!
  end
end
```

`protect_from_async_raise` は名前は仮ですが、  
- ブロックの途中で非同期例外が発生しても状態が壊れない／少なくとも壊れた状態を外に見せない  
ようにするためのラッパーです（内部的にフラグ管理・例外の再送出タイミングの制御などを行っていると考えられます）。

---

3. 影響範囲・注意点  

- 影響範囲  
  - ActiveRecord を使っているすべてのアプリケーションで、`reconnect!` を経由するケース（接続プールの再接続、自動再接続、あるいはユーザーコードから明示的に `reconnect!` を呼ぶ場合）に影響します。
  - 特に、`Timeout.timeout` で DB アクセスまわりをラップしているアプリケーションや、スレッド／Fiber ベースの割り込み・キャンセルを多用している環境で恩恵が大きいです。
- 挙動の変化  
  - 正常系の挙動は基本的に変わりません。  
  - 異常系（タイムアウト・割り込み発生時）に、  
    - 「接続状態・トランザクション状態・キャッシュ状態がより一貫した形で保たれる」  
    ようになります。
- 互換性上の注意点  
  - 「reconnect 中に TimeoutError が起きた場合に、たまたま前のコネクションやトランザクション状態が残っていた」というような、これまでの“偶然の”挙動に依存していたコードは、今回より安定した・明示的な失敗パターンに変わる可能性があります。
  - ただし、それは本来依存すべきでない不安定な挙動であり、今回の変更は実質的にバグフィックスの性質が強いものです。
- パフォーマンス  
  - 非同期例外保護のためのラッパー処理が増えますが、`reconnect!` 自体が頻繁に叩かれるメソッドではないため、一般的なアプリケーションではパフォーマンス影響はほぼ無視できると考えられます。

---

4. 参考情報 (あれば)  

- 元 PR: https://github.com/rails/rails/pull/56231  
- 関連 PR（今回のフォローアップ元）: https://github.com/rails/rails/pull/54738  
- 非同期例外・Timeout と ActiveRecord 接続に関する一般的な注意点:  
  - Ruby の `Timeout.timeout` はスレッドレベルの非同期例外を投げるため、DB 接続やトランザクションなど「途中で例外を投げられると壊れやすい処理」との相性が悪いことが知られています。  
  - Rails 本体側でこうした箇所を保護していく流れが続いており、本 PR もその一環です。

---


## [#56226](https://github.com/rails/rails/pull/56226) Address `Lint/UselessAssignment: Useless assignment to variable - sql.`

**マージ日**: 2025/11/25 | **作成者**: [@yahonda](https://github.com/yahonda)

1. 概要 (1-2文で)  
Rubocop の `Lint/UselessAssignment` に指摘されていた「使われていない変数 `sql` の代入」をテストコードから削除した PR です。機能的な挙動は変えず、静的解析の警告を解消するためのリファクタリングです。

---

2. 変更内容の詳細(あればサンプルコードも含めて)  

対象ファイル:
- `activestorage/test/controllers/representations/redirect_controller_test.rb`

Rubocop 実行時に以下の警告が出ていました:

```text
test/controllers/representations/redirect_controller_test.rb:96:7: W: [Correctable] Lint/UselessAssignment: Useless assignment to variable - sql.
      sql = event.payload[:sql]
      ^^^
```

この `sql` 変数は、その後どこでも参照されておらず、完全に「代入して終わり」になっているため、Rubocop が「無意味な代入」と判断しています。

PR では、この行をまるごと削除しています:

```ruby
# 変更前（該当箇所のイメージ）
ActiveSupport::Notifications.subscribed(callback, "sql.active_record") do
  # ...
  sql = event.payload[:sql]  # ← ここが削除された
  # （この後 sql は一切使われていない）
end
```

変更後は単純にこの代入行だけがなくなり、他のロジック・アサーションには一切手を入れていません。追加行はゼロで、削除行が 1 行のみです。

---

3. 影響範囲・注意点  

- **影響範囲**
  - 対象は Active Storage のコントローラテスト (`representations/redirect_controller_test`) のみです。
  - 実際のアプリケーションコード（プロダクションコード）には一切影響しません。
  - 変数 `sql` はもともと使われていなかったため、この削除によるテストの意味・検証内容の変化もありません。

- **注意点**
  - もし今後このテスト内で `event.payload[:sql]` を検証したくなった場合は、再度変数を導入するか、直接 `event.payload[:sql]` を参照する形でアサートを書く必要があります。
  - Rubocop の `Lint/UselessAssignment` は CI で必須チェックになっている可能性が高いため、同様に「代入して使っていない変数」は他のテストやコードでも警告の対象になります。  
    → デバッグ用の一時変数を残したままコミットしないよう注意が必要です。

---

4. 参考情報 (あれば)  

- 対応している Rubocop の警告: `Lint/UselessAssignment: Useless assignment to variable - sql.`
- 関連 PR: 「Follow up #56225」とあるため、#56225 で行った Rubocop 対応・関連リファクタリングの追加対応と考えられます。
- 変更統計:
  - 変更ファイル数: 1
  - 追加行数: 0
  - 削除行数: 1

---


## [#56225](https://github.com/rails/rails/pull/56225) Ensure variants are loaded and processed synchronously just once

**マージ日**: 2025/11/24 | **作成者**: [@rosa](https://github.com/rosa)

1. 概要 (1-2文で)  
Active Storage のプレビュー用バリアント生成処理で、同一リクエスト内なのにバリアントを二重にロード・生成しようとしていた問題を解消する PR です。`GET /rails/active_storage/representations/redirect` 時に、生成直後のバリアントをレプリカDBから再検索して失敗→再生成して競合する挙動を防ぎ、1回の同期処理で済むようにしています。

---

2. 変更内容の詳細  

### 背景となる問題

ActiveStorage で「プレビュー可能な blob」（動画・PDF など）に対して `GET /rails/active_storage/representations/redirect/...` を叩いたときの流れは大まかに以下です。

1. `ActiveStorage::Representations::BaseController` で `representation` をセットしつつ `processed` を呼んでバリアントを生成  
2. `ActiveStorage::Representations::RedirectController` で `@representation.url` を呼び、リダイレクト先 URL を取得

ところが内部実装上:

- `ActiveStorage::Blob#variant` を呼ぶたびに、新しい `ActiveStorage::VariantWithRecord` インスタンスが生成される  
- `VariantWithRecord#processed` は  
  - レコードがなければ **writer（primary）DB に手動で接続**して variant レコードを作成  
  - そのインスタンス内では `@record` をメモ化している
- しかし 2 回目 (`@representation.url` の中) は「別インスタンス」の `VariantWithRecord#processed` が呼ばれ、  
  - 今度は replica 側で variant レコードの存在チェックを行う
  - レプリカが primary と同期していないタイミングだとレコードが見つからない
  - その結果、プレビューを再ダウンロード＆再加工しようとし、最終的に「レコードは既に存在する」ため作成時に失敗（500）する

という構造的なレースコンディション／二重処理が発生していました。

### この PR の主な変更点

#### 1. `ActiveStorage::Preview` の変更

変更ファイル: `activestorage/app/models/active_storage/preview.rb (+1/-1)`

`ActiveStorage::Preview#image` から返すオブジェクト（内部的には `VariantWithRecord`）の扱いを変えることで、**同じリクエスト内では同じバリアントインスタンスを再利用**するようにしています。

具体的には（実際のコードはリンク先参照ですが概念的には）:

- 以前:
  - `preview.image` を呼ぶたびに `blob.variant(変換オプション)` を呼び、新しい `VariantWithRecord` インスタンスを生成
- 変更後:
  - プレビュー用のバリアントを一度生成したら、インスタンスをプレビューオブジェクト側に持たせて再利用する（= 2 回目以降は `VariantWithRecord` を作り直さない）

これにより、

- 1 回目 (`BaseController` での `processed` 呼び出し) で生成・保存された variant レコードを、そのままメモリ上の同一インスタンスから参照できる
- 2 回目 (`@representation.url`) では、**既に primary で作られたレコードを持っているインスタンス**に対して `processed` 相当の処理が走るため、レプリカ側で再検索し直す必要がなくなる

結果として:

- 変換処理（画像生成）は 1 回で済む
- DB への variant レコード作成も 1 回で済む
- レプリカ／プライマリ間のレイテンシに起因する 500 エラーを回避

という動作になります。

#### 2. テストの追加

変更ファイル: `activestorage/test/controllers/representations/redirect_controller_test.rb (+23/-0)`

`RedirectController` 経由のリクエストで、バリアントの処理が**一度だけ行われること**と、**同じインスタンスが再利用されることを前提とした挙動**をテストで担保しています。

想定されるテスト内容（要約）:

- `GET /rails/active_storage/representations/redirect/...` を叩いたときに:
  - プレビュー用バリアントが同期的に一度だけ生成される
  - 500 エラーにならず、正常にリダイレクト URL が返る
- （必要なら）2回目のリクエスト時は既存の variant レコードが利用される

---

3. 影響範囲・注意点  

- 対象: Active Storage を使っており、かつ「プレビュー可能な blob（動画・PDF 等）」の representation を `GET /rails/active_storage/representations/redirect` で配信しているアプリ
- 主な効果:
  - 同一リクエスト内でのバリアント二重生成が抑制される
  - レプリカDBを用いる構成で発生しうる、「variant レコードが primary にあるのにレプリカで見えない」ことによる 500 エラーが減る
  - CPU 負荷（画像/動画変換の重い処理）の削減、S3 等ストレージへの不要な再アップロード・再ダウンロードの削減
- 注意点:
  - 挙動としてはバグ修正であり、通常の利用では互換性問題はほぼない想定
  - もし独自に `ActiveStorage::Preview` や `VariantWithRecord` にパッチを当てている場合、インスタンスの再利用を前提としたこの変更と競合しないか確認が必要
  - 「同じ `preview.image` 呼び出しなのに毎回別インスタンスであること」を前提にしていた非常に特殊な実装がもしあれば、その前提は崩れます（一般的には想定外）

---

4. 参考情報 (あれば)  

- 該当コード（参考用）
  - `VariantWithRecord` のレコード作成時に writer に接続している箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/variant_with_record.rb#L57-L62
  - `VariantWithRecord` が `@record` をメモ化している箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/variant_with_record.rb#L56-L57
  - `Blob#variant` で毎回新しい `VariantWithRecord` を生成していた箇所  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/models/active_storage/blob/representable.rb#L100-L102
  - representation 設定＆処理呼び出し部分  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/controllers/active_storage/representations/base_controller.rb#L13-L14
  - redirect 用 URL 取得部分  
    https://github.com/rails/rails/blob/17f6e00bce8c35b6c5355450331da170c768e3e0/activestorage/app/controllers/active_storage/representations/redirect_controller.rb#L12

レプリカ構成で Active Storage のプレビュー周りの 500 が出ている場合、この修正を含む Rails バージョンへアップデートすることで改善が見込めます。

---


## [#56216](https://github.com/rails/rails/pull/56216) Fix TimeWithZone#xmlschema when wrapping DateTime local time

**マージ日**: 2025/11/24 | **作成者**: [@drymar](https://github.com/drymar)

1. 概要 (1-2文で)  
ActiveSupport::TimeWithZone#xmlschema が DateTime を「ローカル時刻」としてラップした場合に不正な ISO-8601 文字列を返してしまうリグレッションが修正されています。タイムゾーン部分の扱いを見直し、Time / DateTime どちらをラップしても正しいオフセット付き文字列を返すようになりました。

---

2. 変更内容の詳細 (サンプルコード含む)

### 問題の内容

`ActiveSupport::TimeWithZone` に `DateTime` をローカル時刻として渡した場合、`#xmlschema` が不正な文字列を生成していました。

```ruby
tz  = ActiveSupport::TimeZone["America/New_York"]
twz = ActiveSupport::TimeWithZone.new(nil, tz, DateTime.new(2025, 11, 7, 12))

twz.xmlschema
# 修正前の実際の出力
# => "2025-11-07T12:00:00+00:0-05:00"
```

本来期待されるのは以下のような、1つの正しいオフセットだけを持つ文字列です:

```ruby
"2025-11-07T12:00:00-05:00"
```

原因は、`TimeWithZone#xmlschema` の実装が「`time.iso8601` は末尾が常に `"Z"` で終わる」という前提で書かれていたことです。  
`Time` ではその前提が成り立つケースが多い一方、`DateTime#iso8601` はすでに `+00:00` や `-05:00` などのオフセットを含むため、末尾1文字だけ書き換える処理だと不正な文字列になっていました。

### 修正内容

`TimeWithZone#xmlschema` 内の置換ロジックを、末尾1文字ではなく「タイムゾーン部分全体」を対象に変更しています。

変更点の核心は以下の正規表現置換です:

```ruby
str.sub(/(Z|[+-]\d{2}:\d{2})\z/, formatted_offset(true, "Z"))
```

ポイント:

- `/ (Z | [+-]\d{2}:\d{2}) \z /`
  - 末尾 (`\z`) にある
  - `"Z"` もしくは `+HH:MM` / `-HH:MM` 形式のオフセット
  - をマッチ対象にする。
- `formatted_offset(true, "Z")`
  - TimeWithZone の持つタイムゾーン情報から正しいオフセットを算出し、`±HH:MM` 形式（もしくは 0 のとき `"Z"`）の文字列を返す既存のヘルパーメソッド。
- これにより、元の `Time` / `DateTime` インスタンスがどのようなオフセット表現を持っていても、末尾のタイムゾーン表現を TimeWithZone のタイムゾーンに基づく正しい値に「置き換える」ようになります。

### テストの追加

リグレッションテストが追加されています:

- `test_xmlschema_with_datetime_local_time`

テスト内容は概ね次のような形です（説明用の擬似コード）:

```ruby
tz  = ActiveSupport::TimeZone["America/New_York"]
twz = ActiveSupport::TimeWithZone.new(nil, tz, DateTime.new(2025, 11, 7, 12))

assert_equal "2025-11-07T12:00:00-05:00", twz.xmlschema
```

このテストにより、DateTime をローカル時刻として扱うケースで期待通りの ISO-8601 文字列が生成されることを確認しています。

---

3. 影響範囲・注意点

- 影響を受けるケース:
  - `ActiveSupport::TimeWithZone` に `DateTime` オブジェクトを「ローカル時間」として渡し、`xmlschema`（あるいは `iso8601` 相当のシリアライズ）を利用しているコード。
  - 特に、API レスポンスや XML/JSON シリアライズで TimeWithZone#xmlschema を直接/間接的に呼んでいる場合。
- 振る舞いの変化:
  - バグ修正のみであり、正しい ISO-8601 を生成する方向の変更です。
  - 既に壊れた形式（例: `"2025-11-07T12:00:00+00:0-05:00"`）が出ていた部分は、正しい形式（`"2025-11-07T12:00:00-05:00"`）に変わります。
  - それ以外の Time をラップした `TimeWithZone` については、元々期待されていた動作からの変更はありません。
- 互換性:
  - 仕様としては「正しい ISO-8601 出力をする」という意図に沿った修正なので、通常は後方互換性上の問題はありません。
  - ただし、もし既存システムが「バグったフォーマット」を前提にパースしているような極端なケースがあれば、その部分は修正が必要です（普通はありえない想定です）。

---

4. 参考情報 (あれば)

- 該当 issue: https://github.com/rails/rails/issues/56112  
- 修正対象メソッド:  
  - `ActiveSupport::TimeWithZone#xmlschema`（`activesupport/lib/active_support/time_with_zone.rb`）
- 回帰テスト追加箇所:  
  - `activesupport/test/core_ext/time_with_zone_test.rb`  
- 変更規模:  
  - ファイル数: 2  
  - 追加 14 行 / 削除 3 行  
  - CHANGELOG なしの小規模バグフィックスとして扱われています。

---


## [#56212](https://github.com/rails/rails/pull/56212) Fix CI eager loading when rake tasks invoke :environment before tests

**マージ日**: 2025/11/23 | **作成者**: [@trevorturk](https://github.com/trevorturk)

1. 概要 (1-2文で)
このPRは、テスト環境での`config.eager_load`設定が、CIにおいて`:environment` Rakeタスクがテスト前に実行されると意図した通りに機能しない問題を修正します。

2. 変更内容の詳細
- 問題点として、`config.eager_load = ENV["CI"].present?`が、`tailwindcss-rails`のようなGEMが`:environment`タスクをフックする際に`config.rake_eager_load = false`にオーバーライドされてしまい、CIでeager loadingが無効化されることが挙げられています。
- 本PRでは、`config.rake_eager_load = ENV["CI"].present?`を生成されるテスト環境のテンプレートに追加しました。これにより、Rakeタスクがテスト前に実行されても一貫してeager loadingが実行されるようになります。

3. 影響範囲・注意点
- この修正は、CI環境でのeager loadingが確実に実行されることを保証し、特にZeitwerkのエラーを持つアプリケーションが`bin/rails test`と`bin/rails zeitwerk:check`で異なる結果を出す問題を防ぎます。
- また、このアプローチはRakeタスク自体の取り扱いを変更するのではなく、設定ファイルを調整することで問題を解決しており、他の部分に影響を与えるリスクが少ないと考えられます。

4. 参考情報 (あれば)
- この問題は、Rakeタスクがデフォルトでeager loadingを無効化する方式から来ており、特にRails 5.1以前の遺産問題に関連しています。`rake_eager_load`の設定を利用することで、Rakeタスクにおいても一貫したロード順序を保つことができます。
- 詳細な再現手順と問題の背景については、作成者が用意した最小限の再現ケース（https://github.com/trevorturk/issue_56065）を参照してください。

---


## [#56218](https://github.com/rails/rails/pull/56218) [ci skip] Add extension schema to the db/schema.rb example.

**マージ日**: 2025/11/23 | **作成者**: [@kakudou3](https://github.com/kakudou3)

1. 概要
このプルリクエストは、Ruby on Railsの`db/schema.rb`のサンプルに拡張スキーマ情報を追加することで、Rails 8以降を使用するユーザーの混乱を避けることを目的としています。

2. 変更内容の詳細
`active_record_migrations.md`の`db/schema.rb`のサンプルコードが、スキーマダンパーの更新に伴って不足している情報を反映していなかったため、これを修正しました。具体的には、PostgreSQLの`plpgsql`が`pg_catalog`スキーマに存在することを反映し、サンプルを`pg_catalog.plpgsql`として更新しました。これはPostgreSQL 16.1で確認されています。

3. 影響範囲・注意点
この変更はドキュメントの更新に該当し、直接的なコードの変更やアプリケーションの動作には影響を及ぼしません。しかし、新しいRailsバージョンに移行するユーザーにとって有益であり、拡張機能の有効化に関する理解を助けます。

4. 参考情報
このPRは、以前のPR #52313で行われたスキーマダンパーの変更を反映する意図があります。また、PostgreSQL 16.1の拡張機能情報を参照しており、`plpgsql`が`pg_catalog`スキーマに属することが確認されています。

---

