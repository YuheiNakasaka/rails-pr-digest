---
title: 2025年 12月
description: Ruby on Rails PR Digest - 2025年 12月にマージされたPRの要約
lastUpdated: 2025-12-02
---

# Ruby on Rails PR Digest - 2025年 12月

> このページは [rails/rails](https://github.com/rails/rails) リポジトリにマージされたPull Requestを自動的に収集し、AIで要約したものです。


## [#56265](https://github.com/rails/rails/pull/56265) Stub bundle install for ApiAppGeneratorTest

**マージ日**: 2025/12/1 | **作成者**: [@zzak](https://github.com/zzak)

1. 概要 (1-2文で)  
Api アプリケーションジェネレータのテスト (`ApiAppGeneratorTest`) で、`bundle install`（正確には `kamal` 実行時の Bundler 解決）に依存していた部分をスタブ化し、テストが外部の gem 解決に依存しないようにした PR です。これによりテスト時間が約 3 秒 → 約 1 秒に短縮され、ログノイズも解消されています。

---

2. 変更内容の詳細  

### 何をしている PR か

- `railties/test/generators/api_app_generator_test.rb` の特定のテストに対して、
  - `bundle install` を実行したかのように振る舞うスタブを追加
  - 実際には gem 解決やインストールを行わないようにしている
- これは既に他のテスト（`PluginGeneratorTest`, `ActionTest::Generators::InstallGeneratorTest`）で採用されている「ジェネレータの副作用をスタブするパターン」と揃えたものです。

もともと問題になっていたのは：

- Api ジェネレータのテストの中で `kamal` を使った何らかの処理（おそらく `kamal` コマンドを実行する想定のテンプレート or ジェネレータ）があり、
- 実行時に Bundler が `rails (~> 8.2.0.alpha)` を解決しようとして失敗
- その失敗メッセージが標準出力/エラーに大量に出る上、Bundler の解決処理によりテストが余計に遅くなる

という状況でした。

PR の説明文にあるログから分かるポイント：

- テストは「失敗はしていない」が、内部で `kamal` + Bundler が動いてエラーを吐いているだけ、という状態
- Bundler が `rails (~> 8.2.0.alpha)` の解決を延々試み、膨大なバージョンリストを出力している
- 最後に `Bundler::GemNotFound` が発生し、`kamal` 実行が失敗しているが、テスト側はそのエラーを結果としては無視できる形になっていた

この PR で行われたこと（推測を含むが Rails 他テストのパターン的にかなり確度が高い）：

- 該当テストケースで、ジェネレータが呼び出す `kamal` / `bundle` の実行部分をテストダブルに差し替え
  - 例（イメージ）:

    ```ruby
    def stub_kamal
      File.write("bin/kamal", <<~RUBY)
        #!/usr/bin/env ruby
        # no-op for tests
      RUBY
      FileUtils.chmod("+x", "bin/kamal")
    end
    ```

    もしくは、システムコール層のスタブ:

    ```ruby
    Kamal::Commands.stub(:run, true) do
      # テスト本体
    end
    ```

- 実際に Bundler を起動せず、ジェネレータとして「kamal 向けの設定/ファイルを正しく出力しているか」だけを検証するようにしている
- スタブ化により、ログで出ていた `Could not find gem 'rails (~> 8.2.0.alpha)'` のようなメッセージが一切出なくなり、テストのアサーション数も 6 → 8 に増えているので、スタブした結果をより細かく検証するアサーションが追加された可能性が高いです。

### Before / After の違い（テスト観点）

- Before:
  - 実質的に Bundler / kamal を起動してしまう
  - 失敗ログを大量に吐きつつ、最終的なテスト結果としてはパスしている
  - 実行時間: 約 3.0 秒
  - アサーション: 6 件
- After:
  - Bundler / kamal 実行をスタブ
  - ログは一切出ずクリーン
  - 実行時間: 約 1.2 秒
  - アサーション: 8 件（スタブが正しく呼ばれたこと／生成物の検証が増えた）

---

3. 影響範囲・注意点  

- 影響範囲
  - Rails 本体のプロダクションコードには影響せず、「railties のテストコードのみ」が対象です。
  - 特に `ApiAppGenerator` が `kamal` 用のファイル／設定をどう生成するかをテストする部分のみが変更されています。
- 良くなった点
  - テストが外部の gem レジストリ状態（`rails 8.2.0.alpha` がインストールされているかどうか）に依存しなくなる
  - CI / ローカル環境共にテストが安定し、ノイズログがなくなる
  - テスト実行時間の短縮
- 注意点
  - スタブにより「実際に `kamal` コマンドを走らせたときの挙動」はこのユニットテストではカバーしない形になっています。
    - これは他のジェネレータテストと同じ方針で、「ジェネレータの責務（ファイル生成やコマンド呼び出しのセットアップ）だけ」をテストし、外部ツールの実際の挙動はそのツール自身のテストに任せる、という設計です。
  - `kamal` 側のインターフェースが変わった場合は、このテストだけでは気付きにくくなるので、
    - 統合テストや手動検証など、別レイヤーのテストで補完する必要があります。

---

4. 参考情報 (あれば)  

- 類似パターンがすでに存在するテスト:
  - `PluginGeneratorTest`
  - `ActionTest::Generators::InstallGeneratorTest`
- テストがスタブしている対象は、
  - `bundle install` や外部 CLI（`kamal`）の実行部分
  - Rails のジェネレータテストでは「外部コマンド呼び出しを no-op 化して、生成されたファイルのみ検証する」というパターンが広く使われています。

---


## [#56256](https://github.com/rails/rails/pull/56256) Include HTTP_FORWARDED header in IpSpoofAttackError message if available

**マージ日**: 2025/12/1 | **作成者**: [@zzak](https://github.com/zzak)

1. 概要 (1-2文で)  
Rails の `IpSpoofAttackError` が発生した際のエラーメッセージに、従来の `X-Forwarded-For` に加えて `Forwarded` (`HTTP_FORWARDED`) ヘッダの値も含められるようになりました。これにより、IP なりすまし検出時のデバッグ情報がより充実します。

---

2. 変更内容の詳細  

### どの部分が変わったか

変更ファイル:
- `actionpack/lib/action_dispatch/middleware/remote_ip.rb`
- `actionpack/test/dispatch/request_test.rb`

`ActionDispatch::RemoteIp` ミドルウェア内で `IpSpoofAttackError` を生成するときのメッセージに、利用可能であれば `HTTP_FORWARDED` ヘッダを含めるように修正されています。

従来はおおむね次のようなメッセージでした（例）:

```txt
IP spoofing attack?! HTTP_CLIENT_IP="1.2.3.4" HTTP_X_FORWARDED_FOR="5.6.7.8"
```

この PR により、`Forwarded` ヘッダがある場合は:

```txt
IP spoofing attack?! HTTP_CLIENT_IP="1.2.3.4" HTTP_X_FORWARDED_FOR="5.6.7.8" HTTP_FORWARDED="for=9.10.11.12;proto=https"
```

のように `HTTP_FORWARDED` もメッセージに追加されます。

### コード上のイメージ

※PR 内容からの推定を含むサンプルです（実際の実装のニュアンスとして）:

```ruby
# 例: エラー生成部分のイメージ
raise IpSpoofAttackError.new("IP spoofing attack?! " \
  "HTTP_CLIENT_IP=#{@client_ip.inspect} " \
  "HTTP_X_FORWARDED_FOR=#{forwarded_for.inspect}" \
  "#{forwarded_header_part}"
)

# forwarded_header_part は HTTP_FORWARDED があれば
# ' HTTP_FORWARDED="..."' を付与するような処理
```

テスト (`request_test.rb`) では、`HTTP_FORWARDED` を含むリクエストヘッダで IP spoofing 状況を作り、その例外メッセージ内に `HTTP_FORWARDED` の値が含まれていることを検証するテストが追加されています。

---

3. 影響範囲・注意点  

- **影響範囲**
  - `ActionDispatch::RemoteIp` を使用していて、かつ IP なりすまし (spoofing) 判定が走った場合の「例外メッセージ」が変わります。
  - ランタイムの挙動（例外が発生するかどうか、どの条件で発生するか）自体は変わっていません。あくまで**エラーメッセージの情報量追加**です。

- **ログ解析・監視との互換性**
  - `IpSpoofAttackError` のメッセージ文字列をパースして独自に解析している場合、`HTTP_FORWARDED` の追加でフォーマットが変わる可能性があります。
  - 「メッセージ全体の完全一致 (exact match)」でアラート設定やテストを書いている場合は、これを機に「部分一致」や「正規表現ベース」に変更した方が安全です。

- **Forwarded ヘッダを利用している環境**
  - RFC 7239 準拠の `Forwarded` ヘッダを積極的に使っているリバースプロキシ構成（例: 一部の CDN / LB）では、IP spoofing 検出時のトラブルシューティングがしやすくなります。
  - どのヘッダでどの IP が渡されているかが 1 つの例外メッセージにまとまるため、プロキシの設定ミスや想定外のヘッダ上書きの発見に役立ちます。

---

4. 参考情報 (あれば)  

- 関連 Issue: `#56186`  
  - この PR は、`IpSpoofAttackError` に `Forwarded` ヘッダ情報が含まれないためデバッグが難しい、という報告を解消するものです。
- 対象コンポーネント:  
  - `ActionDispatch::RemoteIp` ミドルウェア  
  - `IpSpoofAttackError` 例外クラス  
- 標準化された `Forwarded` ヘッダ仕様:  
  - RFC 7239 – Forwarded HTTP Extension (プロキシチェーン経由のクライアント情報の標準的な表現方法)

---


## [#56264](https://github.com/rails/rails/pull/56264) `ActiveJob.perform_all_later` should respect `job_class.enqueue_after_transaction_commit`

**マージ日**: 2025/12/1 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
`ActiveJob.perform_all_later` が、ジョブクラスに設定された `enqueue_after_transaction_commit` を正しく尊重するように修正された PR です。これにより、トランザクション完了後にキュー投入すべきジョブが、`perform_all_later` 経由でも期待通りに動作します。

---

2. 変更内容の詳細  

### 背景  
- Rails には、`enqueue_after_transaction_commit` を有効化することで「DBトランザクションがコミットされるまでジョブの enqueue を遅延させる」仕組みがあります。  
- 従来は `perform_later` ではこの設定が反映されていた一方で、複数ジョブを一括で投入する `ActiveJob.perform_all_later(jobs)` 使用時には、このフラグが正しく反映されていませんでした。  
- その結果、本来は「コミット後に enqueue」されるべきジョブが、トランザクション中に即座にキューへ入ってしまう不整合が発生し得ました。

### コードレベルの変更点  

#### 1) `enqueue_after_transaction_commit` 対応ロジックの拡張  
`activejob/lib/active_job/enqueue_after_transaction_commit.rb` に、`perform_all_later` 用の処理が追加されています。  
ざっくりいうと、以下のようなことをやっています:

- 各ジョブクラスの `enqueue_after_transaction_commit` 設定を確認  
- `true` のジョブについては「トランザクションコミット後に enqueue するためのフック」に登録  
- それ以外は従来通り即 enqueue

イメージとしては、`perform_later` と同じようなラッピングロジックを、配列形式の複数ジョブに対して適用する形になっています。

参考となる利用イメージ（疑似コード）:

```ruby
class MyJob < ApplicationJob
  self.enqueue_after_transaction_commit = true

  def perform(record_id)
    # ...
  end
end

ActiveRecord::Base.transaction do
  jobs = [MyJob.new(1), MyJob.new(2)]
  ActiveJob.perform_all_later(jobs)
  # → ここではまだ実際のキューには入らず、
  #   トランザクションがコミットされた後に enqueue される
end
```

#### 2) テストの追加  
`activejob/test/cases/enqueue_after_transaction_commit_test.rb` に 34 行のテストが追加されています。  
主に以下を検証しています:

- `enqueue_after_transaction_commit = true` なジョブを `perform_all_later` で enqueue した場合:
  - トランザクション中は実際のアダプタへ enqueue されない
  - コミット後に enqueue される
- `enqueue_after_transaction_commit = false` or 未設定のジョブは、`perform_all_later` でも即時 enqueue される

これにより `perform_later` と `perform_all_later` 間での挙動の一貫性がテストで担保されています。

---

3. 影響範囲・注意点  

- **影響を受けるケース**  
  - `enqueue_after_transaction_commit` を有効にしている ActiveJob クラスを定義しており  
  - かつ `ActiveJob.perform_all_later(jobs)` を使用しているコード  
  このようなコードは、これまで「トランザクション中に enqueue されていた」ものが、この変更により「トランザクションコミット後に enqueue される」ようになります。

- **既存コードへの実質的な変更**  
  - これまでが「バグ寄りの挙動」であり、`enqueue_after_transaction_commit` の契約通りに動いていなかったため、修正後の挙動のほうが API の意図に沿っています。  
  - ただし、もしこの「バグ前提の挙動」（トランザクション中に enqueue されること）に依存したコードやテストがある場合は、動作タイミングが変わるため注意が必要です。

- **ジョブの順序・実行タイミング**  
  - トランザクションがロールバックされた場合、`enqueue_after_transaction_commit = true` のジョブは enqueue されません。  
  - この特性は元々の `perform_later` と同じであり、`perform_all_later` がこれに揃えられます。

---

4. 参考情報 (あれば)  

- 修正元 PR（バグ報告 / 初期修正案）: https://github.com/rails/rails/pull/56246  
  - この PR はオリジナル作者がメンテナによる force push を許可していなかったため、本 PR (#56264) としてやり直されています。  
- 機能そのものの背景:  
  - Rails ガイド: Active Job のドキュメント（`enqueue_after_transaction_commit` 周辺）  
  - ActiveRecord のトランザクションコールバック (`after_commit`) と連携する仕組みで、DB 一貫性の担保に有用です。

---


## [#56258](https://github.com/rails/rails/pull/56258) Add schematized json for has_json

**マージ日**: 2025/11/30 | **作成者**: [@dhh](https://github.com/dhh)

1. 概要 (1–2文で)  
Rails の JSON 属性に対して「型付き・スキーマ付き」でアクセスできる `schematized_json` 機能が ActiveModel に追加されました。`has_json` / `has_delegated_json` を使うことで、UI から文字列で値を渡しても、DB には boolean / integer / string の正しい JSON 型で保存されるようになります。

---

2. 変更内容の詳細

### 2-1. 機能の概要

- **目的**  
  - JSON カラムを「なんでも入る Hash」ではなく、**事前に決めたキーと型を持つ半構造化データ**として安全に扱えるようにする。
  - フォームや API からはすべて文字列として送られてきても、モデル側で boolean / integer などに **自動キャスト** したい。

- **サポートされる型**
  - `boolean`
  - `integer`
  - `string`
  - **ネストは非対応**（フラットなキーのみ）

### 2-2. 代表的な API と使い方

PR 説明の例をベースに整理します。

```ruby
class Account < ApplicationRecord
  # JSON カラム :settings に対してスキーマ定義
  has_json :settings,
           restrict_creation_to_admins: true,
           max_invites: 10,
           greeting: "Hello!"

  # JSON カラム :flags に対して、delegated なスキーマ定義
  has_delegated_json :flags,
                     beta: false,   # デフォルト値から boolean 型だと解釈
                     staff: :boolean # 明示的に boolean 型
end
```

#### `has_json`

- 対象: モデルの JSON カラム（例: `settings`）
- 使い方:
  - キー名 => デフォルト値 で渡すと、**デフォルト値の型から JSON 型が決まる**
    - `true` / `false` → boolean
    - `10` → integer
    - `"Hello"` → string
  - デフォルト値を持たないキーは `symbol` で型指定できる（例: `staff: :boolean`）

- 実行時の挙動:
  - `Account.new` 時に、定義されたキーに **デフォルト値がセット** される。
  - `before_save` でも再度デフォルトセットが行われる（nil のままの場合などの補完）。

```ruby
a = Account.new
a.settings.restrict_creation_to_admins? # => true (boolean 判定メソッド)
a.settings.max_invites                  # => 10 (integer)
a.settings.greeting                     # => "Hello!" (string)
```

#### `has_delegated_json`

- `has_json` が返す「アクセサオブジェクト」を介さず、**モデル直下にメソッドを生やす**パターン。

```ruby
a = Account.new
a.beta    # => false (flags["beta"] の boolean 値)
a.staff   # => nil   (デフォルトなし、型は boolean)
a.staff = true
a.staff?  # => true
```

### 2-3. 文字列入力からの自動型変換

この PR のキモは、「UI からは全部文字列でも、JSON としては型付きで扱える」点です。

```ruby
a = Account.new

# string を代入しても integer にキャストされる
a.max_invites = "100"
a.max_invites        # => 100 (Integer)
a.settings["max_invites"] # => 100 (JSON 上も数値)

# まとめて Hash で代入した場合も同様
a.settings = {
  "restrict_creation_to_admins" => "false",
  "max_invites" => "500",
  "greeting" => "goodbye"
}

a.settings.restrict_creation_to_admins? # => false (文字列 "false" が boolean に変換)
a.settings.max_invites                  # => 500 (Integer)
a.settings.greeting                     # => "goodbye" (String)
```

サポートされる変換イメージ（推測を含むが一般的には）:

- boolean
  - `"true"`, `"1"`, `"on"`, `"yes"` → `true`
  - `"false"`, `"0"`, `"off"`, `"no"` → `false`
- integer
  - `"-10"`, `"0"`, `"42"` → `-10`, `0`, `42`（`to_i` ベース）
- string
  - そのまま保存（トリム・バリデーション等はこの層では行わない想定）

### 2-4. 実装位置

- 追加ファイル:
  - `activemodel/lib/active_model/schematized_json.rb`
    - スキーマと JSON を結び付ける中核クラス/モジュールが定義されている。
  - `activemodel/lib/active_model.rb`, `activemodel/lib/active_model/api.rb`
    - `schematized_json` 機能を Active Model API から利用できるように require / include。
- テスト:
  - `activemodel/test/cases/schematized_json_test.rb`
    - 型付け、デフォルト適用、キャスト、`has_delegated_json` の挙動などがカバーされている。

---

3. 影響範囲・注意点

- **対象バージョン**  
  - PR #56258 がマージされる Rails の次リリース以降で利用可能（少なくとも edge / main ブランチ）。

- **JSON カラムの前提**
  - DB 側は `json` / `jsonb`（PostgreSQL）など、ネイティブ JSON 型または text + serialize でも動くが、Rails 的には **JSON 属性**として定義されている前提。

- **型の制約**
  - サポートは boolean / integer / string のみ。
  - 配列・オブジェクト・ネストした JSON 構造はサポート外。
    - これらを使いたい場合は、従来通り `store`, `store_accessor`, `serialize`, JSON カスタム型などを使う必要あり。

- **既存データとの整合性**
  - すでに JSON カラムに異なる型が入っている場合、
    - 読み出し時に想定と違う型が来る可能性がある。
    - その場合の挙動（強制キャストかエラーか）は実装依存なので、マイグレーションやデータクレンジングが望ましい。

- **before_save でのデフォルト適用**
  - `before_save` でもデフォルト値が適用されるため、
    - 「ユーザーが nil を明示的に入れたが、保存時にデフォルトで上書きされる」ケースをどう扱うかに注意。
    - 「nil を許容したい」場合は、この schematized_json に乗せるべきか、仕様を検討した方がよい。

- **フォーム/フロントエンド側への利点**
  - すべて文字列で送ってよい、という前提が作れるので、JS 側の型管理がシンプルになる。
  - ただし、boolean の `"true"` / `"false"` などは UI からのバリエーションを考慮したうえで、変換ロジックに合わせた値を送る必要がある。

---

4. 参考情報 (あれば)

- 追加クラス: `ActiveModel::SchematizedJson`（推定名）
- 近い既存機能:
  - `store` / `store_accessor`（ActiveRecord::Store）
  - `attribute :settings, :json, default: { ... }`
- PR:
  - GitHub: rails/rails #56258 「Add schematized json for has_json」  
    （実際のメソッド名・オプション・細かいキャストルールは PR 本文・diff の `schematized_json.rb` / テストコードを参照するとより正確に把握できます）

---

