---
title: 2025年 12月
description: Ruby on Rails PR Digest - 2025年 12月にマージされたPRの要約
lastUpdated: 2025-12-03
---

# Ruby on Rails PR Digest - 2025年 12月

> このページは [rails/rails](https://github.com/rails/rails) リポジトリにマージされたPull Requestを自動的に収集し、AIで要約したものです。


## [#56272](https://github.com/rails/rails/pull/56272) Skip all system test files on app generation

**マージ日**: 2025/12/2 | **作成者**: [@eileencodes](https://github.com/eileencodes)

1. 概要 (1-2文で)  
Rails アプリ生成時に常に作られていた `application_system_test_case.rb` を、システムテストを生成したときに限って作成するように変更した PR です。scaffold でのシステムテストスキップ対応 (#55743) の取りこぼしを補完し、不要なシステムテスト関連ファイルが生成されないようにしています。

---

2. 変更内容の詳細  

### 背景  
- 以前の PR (#55743) で「scaffold 実行時に system test を生成しない」ようにしたが、  
  - `rails new`（アプリ生成）時には依然として `test/application_system_test_case.rb` が自動生成されていた。  
- システムテストを使わないプロジェクトでも、このファイルが毎回作られてしまうのは一貫性がなく、ノイズになる。  

### 主な変更点  

#### 1. アプリ生成時の system test ファイル生成ロジックの変更  
対象: `railties/lib/rails/generators/rails/app/app_generator.rb`

- これまで:  
  - `rails new` でアプリを作ると、デフォルトで `test/application_system_test_case.rb` が生成されていた。
- これから:  
  - `application_system_test_case.rb` は **「システムテストを生成するとき、かつまだ存在しない場合」** にのみ生成されるようになる。  
  - つまり、`rails new` 直後にはこのファイルは存在せず、  
    - `rails g system_test <name>` などを実行したときに初めて `application_system_test_case.rb` が生成される、という動作になる。

この条件分岐は app generator 内のテンプレートコピー条件の見直し・削除/移動で実現されており、app 生成そのものでは system test 用のベースクラスを作らなくなっています。

#### 2. scaffold generator 側での system test ベースクラステンプレート追加  
対象:  
- `railties/lib/rails/generators/test_unit/scaffold/scaffold_generator.rb`
- `railties/lib/rails/generators/test_unit/scaffold/templates/application_system_test_case.rb.tt`

- scaffold 用の test_unit generator に、`application_system_test_case.rb` 用のテンプレート (`.tt`) を追加。  
- scaffold から system test を生成する場合、このテンプレートを使って `test/application_system_test_case.rb` を作成するようにしている。  
- 中身は通常の `ApplicationSystemTestCase` 定義で、例えば以下のような構成になります（イメージ）:

  ```ruby
  # test/application_system_test_case.rb
  require "test_helper"

  class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
    driven_by :selenium, using: :chrome, screen_size: [1400, 1400]
  end
  ```

  ※ 実際のオプション値は Rails の標準テンプレートに準拠。

#### 3. テストの追加・更新  
対象:  
- `railties/test/application/test_runner_test.rb` (+22)
- `railties/test/commands/devcontainer_test.rb` (+8)
- `railties/test/generators/app_generator_test.rb` (-9)

主なポイント:

- **app generator の振る舞い変更に合わせたテスト**  
  - `rails new` 実行後に `test/application_system_test_case.rb` が存在しないこと、  
  - system test 生成時に必要に応じて生成されること  
  を確認するテストが追加/修正されています。

- devcontainer 関連テストの更新  
  - devcontainer 環境での test 実行やファイル有無の前提が変わる影響を受けるため、`test/commands/devcontainer_test.rb` にも検証が追加されています。

- 既存の app generator テストから、もはや生成されない `application_system_test_case.rb` を前提としたアサーションが削除されています (-9 行)。

---

3. 影響範囲・注意点  

- **新規プロジェクト (`rails new`)**
  - これまで: `test/application_system_test_case.rb` が最初から存在した。  
  - これから: デフォルトでは存在しない。  
  - システムテストを使う場合は:
    - `rails g system_test <name>` を実行すれば、自動的に `application_system_test_case.rb` も生成される（まだ存在しない場合）。
    - あるいは自前で作成してもよい。

- **既存プロジェクトへの影響**
  - 既存アプリ内にすでに `application_system_test_case.rb` がある場合、この PR は生成ロジックの変更のみであり、既存ファイルには影響しない。
  - CI 設定やドキュメントなどで「`rails new` 直後に `application_system_test_case.rb` がある前提」を書いている場合は、前提が変わるため更新が必要なことがある。

- **ジェネレータ拡張/テンプレートをいじっている場合**
  - 自作の generator が Rails 標準の app generator / scaffold generator の挙動に依存している場合、  
    - 「ベースのシステムテストケースファイルはアプリ生成時に必ず存在する」  
      という前提はもはや成り立たないので、必要に応じて  
      - 存在チェック (`File.exist?` など)  
      - なければ生成  
      を行うようにする必要があります。

---

4. 参考情報 (あれば)  

- 関連 PR:  
  - システムテスト生成のスキップ対応: https://github.com/rails/rails/pull/55743  
  - 本 PR の問題発見に繋がった PR: https://github.com/rails/rails/pull/56252  

- 該当 PR:  
  - Skip all system test files on app generation (#56272)  
    https://github.com/rails/rails/pull/56272

---


## [#56269](https://github.com/rails/rails/pull/56269) Add a top level bin/test

**マージ日**: 2025/12/2 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
Rails リポジトリのルートに `bin/test` が追加され、サブディレクトリへ `cd` しなくても各サブプロジェクト（activemodel, activerecord など）のテストを直接実行できるようになりました。あわせて、失敗テストの「再実行コマンド」もリポジトリルートからそのままコピペで使える形に改善されています。

---

2. 変更内容の詳細  

### 2-1. `bin/test` の新規追加

リポジトリ直下に `bin/test` が追加され、Rails コアの各コンポーネントのテストを簡単に実行できるようになりました。

使い方の例（PR本文のまま）:

```bash
# コンポーネント単位のテスト
$ bin/test activemodel
...

# 特定ファイルだけを実行
$ bin/test activemodel/test/cases/dirty_test.rb
...

# 複数ファイル + 任意のオプション（ここでは -v）を付けて実行
$ bin/test activemodel/test/cases/dirty_test.rb activemodel/test/cases/error_test.rb -v
...
```

特徴:

- **リポジトリルートから実行可能**  
  いちいち `cd activemodel` や `cd activerecord` せずにテストを叩ける。
- **単一サブプロジェクト内でのテスト実行を想定**  
  一回のコマンドで「activemodel と activerecord を同時に」など、複数サブプロジェクトを混在させた実行はサポートしていないと明記されています。
- おそらく内部的には既存の `tools/test.rb` / `tools/test_common.rb` を呼び出す薄いラッパーになっており、引数に応じて対象コンポーネントを解決している形です。

`bin/test` の追加によって、これまで

```bash
cd activemodel && bin/test test/cases/dirty_test.rb
```

のようにしていた作業が

```bash
bin/test activemodel/test/cases/dirty_test.rb
```

だけで済むようになります。

### 2-2. テストレポーター (`reporter.rb`) の修正

`railties/lib/rails/test_unit/reporter.rb` が変更され、Rails 自身のテストを実行したときに表示される「失敗テストの再実行コマンド」が、ルートディレクトリからそのまま使える形に変わりました。

従来は、CI やローカルで失敗したときに、次のようなコマンドが表示されていました:

```bash
bin/rails test /rails/activerecord/test/cases/adapters/postgresql/connection_test.rb:187
```

- 絶対パス (`/rails/...`) になっていて、そのままコピペしても意図通りに動きにくい。
- 実行パスも `bin/rails` で、コンポーネント単体テストを回す文脈とやや合わない。

これが PR によって、以下のようになります:

```bash
bin/test activerecord/test/cases/adapters/postgresql/connection_test.rb:187
```

- リポジトリルートからの**相対パス**になり、そのままコピペで実行可能。
- コマンドが `bin/test` に統一され、今回追加されたワークフローと整合します。

### 2-3. `tools/test.rb` / `tools/test_common.rb` の微修正

`tools/test.rb` と `tools/test_common.rb` にはそれぞれ 1〜2 行程度の軽微な修正が入っています。

推測される内容:

- `bin/test` からの呼び出しをサポートするために、**エントリーポイントの扱い**や**引数のパース方法**を少しだけ調整。
- コンポーネント名（`activemodel`, `activerecord` など）とパスの解決ロジックを `bin/test` と共有するための小さな共通化。

このあたりは内部実装の整合性調整であり、外部 API/インターフェースとしては主に `bin/test` の追加とレポーターの出力変更が本質的な変更です。

---

3. 影響範囲・注意点  

- **対象は Rails リポジトリの開発者・コントリビューター**  
  Rails を利用するアプリ開発者向けではなく、「Rails 本体のテストを書く・直す人」の開発体験改善が主目的です。
- **既存のテスト実行方法は引き続き使用可能**  
  `cd activerecord && bundle exec ruby -Itest test/cases/...` のような既存手法は変わらず動作し、`bin/test` は追加のエイリアス・ラッパーの位置づけです。
- **複数サブプロジェクトへの同時テスト実行はサポート外**  
  一回の `bin/test` 呼び出しで `activemodel` と `activerecord` のテストを同時に指定するような使い方は想定されていません。  
  → そのようなケースでは、これまで通り各ディレクトリで個別に実行するか、独自スクリプトを使う必要があります。
- **CI ログやローカル実行時の「再実行コマンド」が変わる**  
  今後は `bin/test ...` 形式のコマンドが出力されるため、ドキュメント・社内 Wiki 等で「失敗テストの再実行方法」を案内している場合は、必要に応じて記述を更新するとよいです。
- **パス前提の変化**  
  再実行コマンドは「リポジトリルートからの相対パス」を前提にしています。そのため、コマンドをコピペするときは「Rails リポジトリのルートで実行しているか」を意識する必要があります。

---

4. 参考情報 (あれば)  

- PR 本文: Add a top level bin/test (#56269)
- CI の実行例（Buildkite）:  
  https://buildkite.com/rails/rails/builds/124229#019ade2f-ecf0-485f-ba07-5e26f23fa3e9/1245-1259  
  → 実際に `bin/test` ベースの再実行コマンドが出ているログを確認できます。
- 関連ファイル:
  - `bin/test`（新規追加スクリプト）
  - `railties/lib/rails/test_unit/reporter.rb`（再実行コマンドの出力元）
  - `tools/test.rb`, `tools/test_common.rb`（既存のテスト実行ユーティリティ）

---


## [#56265](https://github.com/rails/rails/pull/56265) Stub bundle install for ApiAppGeneratorTest

**マージ日**: 2025/12/1 | **作成者**: [@zzak](https://github.com/zzak)

1. 概要 (1-2文で)  
Api アプリケーションジェネレータのテスト (`ApiAppGeneratorTest`) で、`bundle install`（正確には `kamal` 実行時の Bundler 解決）に依存していた部分をスタブ化し、テストが外部の gem 解決に依存しないようにした PR です。これによりテスト時間が約 3 秒 → 約 1 秒に短縮され、ログノイズも解消されています。

---

2. 変更内容の詳細  

### 何をしている PR か

- `railties/test/generators/api_app_generator_test.rb` の特定のテストに対して、
  - `bundle install` を実行したかのように振る舞うスタブを追加
  - 実際には gem 解決やインストールを行わないようにしている
- これは既に他のテスト（`PluginGeneratorTest`, `ActionTest::Generators::InstallGeneratorTest`）で採用されている「ジェネレータの副作用をスタブするパターン」と揃えたものです。

もともと問題になっていたのは：

- Api ジェネレータのテストの中で `kamal` を使った何らかの処理（おそらく `kamal` コマンドを実行する想定のテンプレート or ジェネレータ）があり、
- 実行時に Bundler が `rails (~> 8.2.0.alpha)` を解決しようとして失敗
- その失敗メッセージが標準出力/エラーに大量に出る上、Bundler の解決処理によりテストが余計に遅くなる

という状況でした。

PR の説明文にあるログから分かるポイント：

- テストは「失敗はしていない」が、内部で `kamal` + Bundler が動いてエラーを吐いているだけ、という状態
- Bundler が `rails (~> 8.2.0.alpha)` の解決を延々試み、膨大なバージョンリストを出力している
- 最後に `Bundler::GemNotFound` が発生し、`kamal` 実行が失敗しているが、テスト側はそのエラーを結果としては無視できる形になっていた

この PR で行われたこと（推測を含むが Rails 他テストのパターン的にかなり確度が高い）：

- 該当テストケースで、ジェネレータが呼び出す `kamal` / `bundle` の実行部分をテストダブルに差し替え
  - 例（イメージ）:

    ```ruby
    def stub_kamal
      File.write("bin/kamal", <<~RUBY)
        #!/usr/bin/env ruby
        # no-op for tests
      RUBY
      FileUtils.chmod("+x", "bin/kamal")
    end
    ```

    もしくは、システムコール層のスタブ:

    ```ruby
    Kamal::Commands.stub(:run, true) do
      # テスト本体
    end
    ```

- 実際に Bundler を起動せず、ジェネレータとして「kamal 向けの設定/ファイルを正しく出力しているか」だけを検証するようにしている
- スタブ化により、ログで出ていた `Could not find gem 'rails (~> 8.2.0.alpha)'` のようなメッセージが一切出なくなり、テストのアサーション数も 6 → 8 に増えているので、スタブした結果をより細かく検証するアサーションが追加された可能性が高いです。

### Before / After の違い（テスト観点）

- Before:
  - 実質的に Bundler / kamal を起動してしまう
  - 失敗ログを大量に吐きつつ、最終的なテスト結果としてはパスしている
  - 実行時間: 約 3.0 秒
  - アサーション: 6 件
- After:
  - Bundler / kamal 実行をスタブ
  - ログは一切出ずクリーン
  - 実行時間: 約 1.2 秒
  - アサーション: 8 件（スタブが正しく呼ばれたこと／生成物の検証が増えた）

---

3. 影響範囲・注意点  

- 影響範囲
  - Rails 本体のプロダクションコードには影響せず、「railties のテストコードのみ」が対象です。
  - 特に `ApiAppGenerator` が `kamal` 用のファイル／設定をどう生成するかをテストする部分のみが変更されています。
- 良くなった点
  - テストが外部の gem レジストリ状態（`rails 8.2.0.alpha` がインストールされているかどうか）に依存しなくなる
  - CI / ローカル環境共にテストが安定し、ノイズログがなくなる
  - テスト実行時間の短縮
- 注意点
  - スタブにより「実際に `kamal` コマンドを走らせたときの挙動」はこのユニットテストではカバーしない形になっています。
    - これは他のジェネレータテストと同じ方針で、「ジェネレータの責務（ファイル生成やコマンド呼び出しのセットアップ）だけ」をテストし、外部ツールの実際の挙動はそのツール自身のテストに任せる、という設計です。
  - `kamal` 側のインターフェースが変わった場合は、このテストだけでは気付きにくくなるので、
    - 統合テストや手動検証など、別レイヤーのテストで補完する必要があります。

---

4. 参考情報 (あれば)  

- 類似パターンがすでに存在するテスト:
  - `PluginGeneratorTest`
  - `ActionTest::Generators::InstallGeneratorTest`
- テストがスタブしている対象は、
  - `bundle install` や外部 CLI（`kamal`）の実行部分
  - Rails のジェネレータテストでは「外部コマンド呼び出しを no-op 化して、生成されたファイルのみ検証する」というパターンが広く使われています。

---


## [#56256](https://github.com/rails/rails/pull/56256) Include HTTP_FORWARDED header in IpSpoofAttackError message if available

**マージ日**: 2025/12/1 | **作成者**: [@zzak](https://github.com/zzak)

1. 概要 (1-2文で)  
Rails の `IpSpoofAttackError` が発生した際のエラーメッセージに、従来の `X-Forwarded-For` に加えて `Forwarded` (`HTTP_FORWARDED`) ヘッダの値も含められるようになりました。これにより、IP なりすまし検出時のデバッグ情報がより充実します。

---

2. 変更内容の詳細  

### どの部分が変わったか

変更ファイル:
- `actionpack/lib/action_dispatch/middleware/remote_ip.rb`
- `actionpack/test/dispatch/request_test.rb`

`ActionDispatch::RemoteIp` ミドルウェア内で `IpSpoofAttackError` を生成するときのメッセージに、利用可能であれば `HTTP_FORWARDED` ヘッダを含めるように修正されています。

従来はおおむね次のようなメッセージでした（例）:

```txt
IP spoofing attack?! HTTP_CLIENT_IP="1.2.3.4" HTTP_X_FORWARDED_FOR="5.6.7.8"
```

この PR により、`Forwarded` ヘッダがある場合は:

```txt
IP spoofing attack?! HTTP_CLIENT_IP="1.2.3.4" HTTP_X_FORWARDED_FOR="5.6.7.8" HTTP_FORWARDED="for=9.10.11.12;proto=https"
```

のように `HTTP_FORWARDED` もメッセージに追加されます。

### コード上のイメージ

※PR 内容からの推定を含むサンプルです（実際の実装のニュアンスとして）:

```ruby
# 例: エラー生成部分のイメージ
raise IpSpoofAttackError.new("IP spoofing attack?! " \
  "HTTP_CLIENT_IP=#{@client_ip.inspect} " \
  "HTTP_X_FORWARDED_FOR=#{forwarded_for.inspect}" \
  "#{forwarded_header_part}"
)

# forwarded_header_part は HTTP_FORWARDED があれば
# ' HTTP_FORWARDED="..."' を付与するような処理
```

テスト (`request_test.rb`) では、`HTTP_FORWARDED` を含むリクエストヘッダで IP spoofing 状況を作り、その例外メッセージ内に `HTTP_FORWARDED` の値が含まれていることを検証するテストが追加されています。

---

3. 影響範囲・注意点  

- **影響範囲**
  - `ActionDispatch::RemoteIp` を使用していて、かつ IP なりすまし (spoofing) 判定が走った場合の「例外メッセージ」が変わります。
  - ランタイムの挙動（例外が発生するかどうか、どの条件で発生するか）自体は変わっていません。あくまで**エラーメッセージの情報量追加**です。

- **ログ解析・監視との互換性**
  - `IpSpoofAttackError` のメッセージ文字列をパースして独自に解析している場合、`HTTP_FORWARDED` の追加でフォーマットが変わる可能性があります。
  - 「メッセージ全体の完全一致 (exact match)」でアラート設定やテストを書いている場合は、これを機に「部分一致」や「正規表現ベース」に変更した方が安全です。

- **Forwarded ヘッダを利用している環境**
  - RFC 7239 準拠の `Forwarded` ヘッダを積極的に使っているリバースプロキシ構成（例: 一部の CDN / LB）では、IP spoofing 検出時のトラブルシューティングがしやすくなります。
  - どのヘッダでどの IP が渡されているかが 1 つの例外メッセージにまとまるため、プロキシの設定ミスや想定外のヘッダ上書きの発見に役立ちます。

---

4. 参考情報 (あれば)  

- 関連 Issue: `#56186`  
  - この PR は、`IpSpoofAttackError` に `Forwarded` ヘッダ情報が含まれないためデバッグが難しい、という報告を解消するものです。
- 対象コンポーネント:  
  - `ActionDispatch::RemoteIp` ミドルウェア  
  - `IpSpoofAttackError` 例外クラス  
- 標準化された `Forwarded` ヘッダ仕様:  
  - RFC 7239 – Forwarded HTTP Extension (プロキシチェーン経由のクライアント情報の標準的な表現方法)

---


## [#56264](https://github.com/rails/rails/pull/56264) `ActiveJob.perform_all_later` should respect `job_class.enqueue_after_transaction_commit`

**マージ日**: 2025/12/1 | **作成者**: [@byroot](https://github.com/byroot)

1. 概要 (1-2文で)  
`ActiveJob.perform_all_later` が、ジョブクラスに設定された `enqueue_after_transaction_commit` を正しく尊重するように修正された PR です。これにより、トランザクション完了後にキュー投入すべきジョブが、`perform_all_later` 経由でも期待通りに動作します。

---

2. 変更内容の詳細  

### 背景  
- Rails には、`enqueue_after_transaction_commit` を有効化することで「DBトランザクションがコミットされるまでジョブの enqueue を遅延させる」仕組みがあります。  
- 従来は `perform_later` ではこの設定が反映されていた一方で、複数ジョブを一括で投入する `ActiveJob.perform_all_later(jobs)` 使用時には、このフラグが正しく反映されていませんでした。  
- その結果、本来は「コミット後に enqueue」されるべきジョブが、トランザクション中に即座にキューへ入ってしまう不整合が発生し得ました。

### コードレベルの変更点  

#### 1) `enqueue_after_transaction_commit` 対応ロジックの拡張  
`activejob/lib/active_job/enqueue_after_transaction_commit.rb` に、`perform_all_later` 用の処理が追加されています。  
ざっくりいうと、以下のようなことをやっています:

- 各ジョブクラスの `enqueue_after_transaction_commit` 設定を確認  
- `true` のジョブについては「トランザクションコミット後に enqueue するためのフック」に登録  
- それ以外は従来通り即 enqueue

イメージとしては、`perform_later` と同じようなラッピングロジックを、配列形式の複数ジョブに対して適用する形になっています。

参考となる利用イメージ（疑似コード）:

```ruby
class MyJob < ApplicationJob
  self.enqueue_after_transaction_commit = true

  def perform(record_id)
    # ...
  end
end

ActiveRecord::Base.transaction do
  jobs = [MyJob.new(1), MyJob.new(2)]
  ActiveJob.perform_all_later(jobs)
  # → ここではまだ実際のキューには入らず、
  #   トランザクションがコミットされた後に enqueue される
end
```

#### 2) テストの追加  
`activejob/test/cases/enqueue_after_transaction_commit_test.rb` に 34 行のテストが追加されています。  
主に以下を検証しています:

- `enqueue_after_transaction_commit = true` なジョブを `perform_all_later` で enqueue した場合:
  - トランザクション中は実際のアダプタへ enqueue されない
  - コミット後に enqueue される
- `enqueue_after_transaction_commit = false` or 未設定のジョブは、`perform_all_later` でも即時 enqueue される

これにより `perform_later` と `perform_all_later` 間での挙動の一貫性がテストで担保されています。

---

3. 影響範囲・注意点  

- **影響を受けるケース**  
  - `enqueue_after_transaction_commit` を有効にしている ActiveJob クラスを定義しており  
  - かつ `ActiveJob.perform_all_later(jobs)` を使用しているコード  
  このようなコードは、これまで「トランザクション中に enqueue されていた」ものが、この変更により「トランザクションコミット後に enqueue される」ようになります。

- **既存コードへの実質的な変更**  
  - これまでが「バグ寄りの挙動」であり、`enqueue_after_transaction_commit` の契約通りに動いていなかったため、修正後の挙動のほうが API の意図に沿っています。  
  - ただし、もしこの「バグ前提の挙動」（トランザクション中に enqueue されること）に依存したコードやテストがある場合は、動作タイミングが変わるため注意が必要です。

- **ジョブの順序・実行タイミング**  
  - トランザクションがロールバックされた場合、`enqueue_after_transaction_commit = true` のジョブは enqueue されません。  
  - この特性は元々の `perform_later` と同じであり、`perform_all_later` がこれに揃えられます。

---

4. 参考情報 (あれば)  

- 修正元 PR（バグ報告 / 初期修正案）: https://github.com/rails/rails/pull/56246  
  - この PR はオリジナル作者がメンテナによる force push を許可していなかったため、本 PR (#56264) としてやり直されています。  
- 機能そのものの背景:  
  - Rails ガイド: Active Job のドキュメント（`enqueue_after_transaction_commit` 周辺）  
  - ActiveRecord のトランザクションコールバック (`after_commit`) と連携する仕組みで、DB 一貫性の担保に有用です。

---


## [#56258](https://github.com/rails/rails/pull/56258) Add schematized json for has_json

**マージ日**: 2025/11/30 | **作成者**: [@dhh](https://github.com/dhh)

1. 概要 (1–2文で)  
Rails の JSON 属性に対して「型付き・スキーマ付き」でアクセスできる `schematized_json` 機能が ActiveModel に追加されました。`has_json` / `has_delegated_json` を使うことで、UI から文字列で値を渡しても、DB には boolean / integer / string の正しい JSON 型で保存されるようになります。

---

2. 変更内容の詳細

### 2-1. 機能の概要

- **目的**  
  - JSON カラムを「なんでも入る Hash」ではなく、**事前に決めたキーと型を持つ半構造化データ**として安全に扱えるようにする。
  - フォームや API からはすべて文字列として送られてきても、モデル側で boolean / integer などに **自動キャスト** したい。

- **サポートされる型**
  - `boolean`
  - `integer`
  - `string`
  - **ネストは非対応**（フラットなキーのみ）

### 2-2. 代表的な API と使い方

PR 説明の例をベースに整理します。

```ruby
class Account < ApplicationRecord
  # JSON カラム :settings に対してスキーマ定義
  has_json :settings,
           restrict_creation_to_admins: true,
           max_invites: 10,
           greeting: "Hello!"

  # JSON カラム :flags に対して、delegated なスキーマ定義
  has_delegated_json :flags,
                     beta: false,   # デフォルト値から boolean 型だと解釈
                     staff: :boolean # 明示的に boolean 型
end
```

#### `has_json`

- 対象: モデルの JSON カラム（例: `settings`）
- 使い方:
  - キー名 => デフォルト値 で渡すと、**デフォルト値の型から JSON 型が決まる**
    - `true` / `false` → boolean
    - `10` → integer
    - `"Hello"` → string
  - デフォルト値を持たないキーは `symbol` で型指定できる（例: `staff: :boolean`）

- 実行時の挙動:
  - `Account.new` 時に、定義されたキーに **デフォルト値がセット** される。
  - `before_save` でも再度デフォルトセットが行われる（nil のままの場合などの補完）。

```ruby
a = Account.new
a.settings.restrict_creation_to_admins? # => true (boolean 判定メソッド)
a.settings.max_invites                  # => 10 (integer)
a.settings.greeting                     # => "Hello!" (string)
```

#### `has_delegated_json`

- `has_json` が返す「アクセサオブジェクト」を介さず、**モデル直下にメソッドを生やす**パターン。

```ruby
a = Account.new
a.beta    # => false (flags["beta"] の boolean 値)
a.staff   # => nil   (デフォルトなし、型は boolean)
a.staff = true
a.staff?  # => true
```

### 2-3. 文字列入力からの自動型変換

この PR のキモは、「UI からは全部文字列でも、JSON としては型付きで扱える」点です。

```ruby
a = Account.new

# string を代入しても integer にキャストされる
a.max_invites = "100"
a.max_invites        # => 100 (Integer)
a.settings["max_invites"] # => 100 (JSON 上も数値)

# まとめて Hash で代入した場合も同様
a.settings = {
  "restrict_creation_to_admins" => "false",
  "max_invites" => "500",
  "greeting" => "goodbye"
}

a.settings.restrict_creation_to_admins? # => false (文字列 "false" が boolean に変換)
a.settings.max_invites                  # => 500 (Integer)
a.settings.greeting                     # => "goodbye" (String)
```

サポートされる変換イメージ（推測を含むが一般的には）:

- boolean
  - `"true"`, `"1"`, `"on"`, `"yes"` → `true`
  - `"false"`, `"0"`, `"off"`, `"no"` → `false`
- integer
  - `"-10"`, `"0"`, `"42"` → `-10`, `0`, `42`（`to_i` ベース）
- string
  - そのまま保存（トリム・バリデーション等はこの層では行わない想定）

### 2-4. 実装位置

- 追加ファイル:
  - `activemodel/lib/active_model/schematized_json.rb`
    - スキーマと JSON を結び付ける中核クラス/モジュールが定義されている。
  - `activemodel/lib/active_model.rb`, `activemodel/lib/active_model/api.rb`
    - `schematized_json` 機能を Active Model API から利用できるように require / include。
- テスト:
  - `activemodel/test/cases/schematized_json_test.rb`
    - 型付け、デフォルト適用、キャスト、`has_delegated_json` の挙動などがカバーされている。

---

3. 影響範囲・注意点

- **対象バージョン**  
  - PR #56258 がマージされる Rails の次リリース以降で利用可能（少なくとも edge / main ブランチ）。

- **JSON カラムの前提**
  - DB 側は `json` / `jsonb`（PostgreSQL）など、ネイティブ JSON 型または text + serialize でも動くが、Rails 的には **JSON 属性**として定義されている前提。

- **型の制約**
  - サポートは boolean / integer / string のみ。
  - 配列・オブジェクト・ネストした JSON 構造はサポート外。
    - これらを使いたい場合は、従来通り `store`, `store_accessor`, `serialize`, JSON カスタム型などを使う必要あり。

- **既存データとの整合性**
  - すでに JSON カラムに異なる型が入っている場合、
    - 読み出し時に想定と違う型が来る可能性がある。
    - その場合の挙動（強制キャストかエラーか）は実装依存なので、マイグレーションやデータクレンジングが望ましい。

- **before_save でのデフォルト適用**
  - `before_save` でもデフォルト値が適用されるため、
    - 「ユーザーが nil を明示的に入れたが、保存時にデフォルトで上書きされる」ケースをどう扱うかに注意。
    - 「nil を許容したい」場合は、この schematized_json に乗せるべきか、仕様を検討した方がよい。

- **フォーム/フロントエンド側への利点**
  - すべて文字列で送ってよい、という前提が作れるので、JS 側の型管理がシンプルになる。
  - ただし、boolean の `"true"` / `"false"` などは UI からのバリエーションを考慮したうえで、変換ロジックに合わせた値を送る必要がある。

---

4. 参考情報 (あれば)

- 追加クラス: `ActiveModel::SchematizedJson`（推定名）
- 近い既存機能:
  - `store` / `store_accessor`（ActiveRecord::Store）
  - `attribute :settings, :json, default: { ... }`
- PR:
  - GitHub: rails/rails #56258 「Add schematized json for has_json」  
    （実際のメソッド名・オプション・細かいキャストルールは PR 本文・diff の `schematized_json.rb` / テストコードを参照するとより正確に把握できます）

---

